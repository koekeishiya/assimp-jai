//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



AI_CONFIG_GLOB_MEASURE_TIME :: "GLOB_MEASURE_TIME";

AI_CONFIG_IMPORT_NO_SKELETON_MESHES :: "IMPORT_NO_SKELETON_MESHES";

AI_CONFIG_PP_SBBC_MAX_BONES :: "PP_SBBC_MAX_BONES";

AI_SBBC_DEFAULT_MAX_BONES :: 60;

AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE :: "PP_CT_MAX_SMOOTHING_ANGLE";

AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX :: "PP_CT_TEXTURE_CHANNEL_INDEX";

AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE :: "PP_GSN_MAX_SMOOTHING_ANGLE";

AI_CONFIG_IMPORT_MDL_COLORMAP :: "IMPORT_MDL_COLORMAP";

AI_CONFIG_PP_RRM_EXCLUDE_LIST :: "PP_RRM_EXCLUDE_LIST";

AI_CONFIG_PP_PTV_KEEP_HIERARCHY :: "PP_PTV_KEEP_HIERARCHY";

AI_CONFIG_PP_PTV_NORMALIZE :: "PP_PTV_NORMALIZE";

AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION :: "PP_PTV_ADD_ROOT_TRANSFORMATION";

AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION :: "PP_PTV_ROOT_TRANSFORMATION";

AI_CONFIG_CHECK_IDENTITY_MATRIX_EPSILON :: "CHECK_IDENTITY_MATRIX_EPSILON";

AI_CONFIG_CHECK_IDENTITY_MATRIX_EPSILON_DEFAULT :: 10.0e-3;

AI_CONFIG_PP_FD_REMOVE :: "PP_FD_REMOVE";

AI_CONFIG_PP_FD_CHECKAREA :: "PP_FD_CHECKAREA";

AI_CONFIG_PP_OG_EXCLUDE_LIST :: "PP_OG_EXCLUDE_LIST";

AI_CONFIG_PP_SLM_TRIANGLE_LIMIT :: "PP_SLM_TRIANGLE_LIMIT";

AI_SLM_DEFAULT_MAX_TRIANGLES :: 1000000;

AI_CONFIG_PP_SLM_VERTEX_LIMIT :: "PP_SLM_VERTEX_LIMIT";

AI_SLM_DEFAULT_MAX_VERTICES :: 1000000;

AI_CONFIG_PP_LBW_MAX_WEIGHTS :: "PP_LBW_MAX_WEIGHTS";

AI_LMW_MAX_WEIGHTS :: 0x4;

AI_CONFIG_PP_DB_THRESHOLD :: "PP_DB_THRESHOLD";

AI_DEBONE_THRESHOLD :: 1.0;

AI_CONFIG_PP_DB_ALL_OR_NONE :: "PP_DB_ALL_OR_NONE";

PP_ICL_PTCACHE_SIZE :: 12;

AI_CONFIG_PP_ICL_PTCACHE_SIZE :: "PP_ICL_PTCACHE_SIZE";

AI_CONFIG_PP_RVC_FLAGS :: "PP_RVC_FLAGS";

AI_CONFIG_PP_SBP_REMOVE :: "PP_SBP_REMOVE";

AI_CONFIG_PP_FID_ANIM_ACCURACY :: "PP_FID_ANIM_ACCURACY";

AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS :: "PP_FID_IGNORE_TEXTURECOORDS";

AI_UVTRAFO_SCALING :: 0x1;

AI_UVTRAFO_ROTATION :: 0x2;

AI_UVTRAFO_TRANSLATION :: 0x4;

AI_UVTRAFO_ALL :: AI_UVTRAFO_SCALING | AI_UVTRAFO_ROTATION | AI_UVTRAFO_TRANSLATION;

AI_CONFIG_PP_TUV_EVALUATE :: "PP_TUV_EVALUATE";

AI_CONFIG_FAVOUR_SPEED :: "FAVOUR_SPEED";

AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER :: "IMPORT_SCHEMA_DOCUMENT_PROVIDER";

AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS :: "IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS";

AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS :: "IMPORT_FBX_READ_ALL_MATERIALS";

AI_CONFIG_IMPORT_FBX_READ_MATERIALS :: "IMPORT_FBX_READ_MATERIALS";

AI_CONFIG_IMPORT_FBX_READ_TEXTURES :: "IMPORT_FBX_READ_TEXTURES";

AI_CONFIG_IMPORT_FBX_READ_CAMERAS :: "IMPORT_FBX_READ_CAMERAS";

AI_CONFIG_IMPORT_FBX_READ_LIGHTS :: "IMPORT_FBX_READ_LIGHTS";

AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS :: "IMPORT_FBX_READ_ANIMATIONS";

AI_CONFIG_IMPORT_FBX_READ_WEIGHTS :: "IMPORT_FBX_READ_WEIGHTS";

AI_CONFIG_IMPORT_FBX_STRICT_MODE :: "IMPORT_FBX_STRICT_MODE";

AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS :: "IMPORT_FBX_PRESERVE_PIVOTS";

AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES :: "IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES";

AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING :: "AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING";

AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES :: "AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES";

AI_CONFIG_FBX_CONVERT_TO_M :: "AI_CONFIG_FBX_CONVERT_TO_M";

AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER :: "AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER";

AI_CONFIG_IMPORT_GLOBAL_KEYFRAME :: "IMPORT_GLOBAL_KEYFRAME";

AI_CONFIG_IMPORT_MD3_KEYFRAME :: "IMPORT_MD3_KEYFRAME";
AI_CONFIG_IMPORT_MD2_KEYFRAME :: "IMPORT_MD2_KEYFRAME";
AI_CONFIG_IMPORT_MDL_KEYFRAME :: "IMPORT_MDL_KEYFRAME";
AI_CONFIG_IMPORT_MDC_KEYFRAME :: "IMPORT_MDC_KEYFRAME";
AI_CONFIG_IMPORT_SMD_KEYFRAME :: "IMPORT_SMD_KEYFRAME";
AI_CONFIG_IMPORT_UNREAL_KEYFRAME :: "IMPORT_UNREAL_KEYFRAME";

AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS :: "IMPORT_MDL_HL1_READ_ANIMATIONS";

AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS :: "IMPORT_MDL_HL1_READ_ANIMATION_EVENTS";

AI_CONFIG_IMPORT_MDL_HL1_TRANSFORM_COORD_SYSTEM :: "TRANSFORM COORDSYSTEM FOR HS! MODELS";

AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS :: "IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS";

AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS :: "IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS";

AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS :: "IMPORT_MDL_HL1_READ_ATTACHMENTS";

AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS :: "IMPORT_MDL_HL1_READ_BONE_CONTROLLERS";

AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES :: "IMPORT_MDL_HL1_READ_HITBOXES";

AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO :: "IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO";

AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST :: "IMPORT_SMD_LOAD_ANIMATION_LIST";

AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL :: "IMPORT_AC_SEPARATE_BFCULL";

AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION :: "IMPORT_AC_EVAL_SUBDIVISION";

AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS :: "UNREAL_HANDLE_FLAGS";

AI_CONFIG_IMPORT_TER_MAKE_UVS :: "IMPORT_TER_MAKE_UVS";

AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS :: "IMPORT_ASE_RECONSTRUCT_NORMALS";

AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART :: "IMPORT_MD3_HANDLE_MULTIPART";

AI_CONFIG_IMPORT_MD3_SKIN_NAME :: "IMPORT_MD3_SKIN_NAME";

AI_CONFIG_IMPORT_MD3_LOAD_SHADERS :: "IMPORT_MD3_LOAD_SHADERS";

AI_CONFIG_IMPORT_MD3_SHADER_SRC :: "IMPORT_MD3_SHADER_SRC";

AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY :: "IMPORT_LWO_ONE_LAYER_ONLY";

AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD :: "IMPORT_MD5_NO_ANIM_AUTOLOAD";

AI_CONFIG_IMPORT_LWS_ANIM_START :: "IMPORT_LWS_ANIM_START";

AI_CONFIG_IMPORT_LWS_ANIM_END :: "IMPORT_LWS_ANIM_END";

AI_CONFIG_IMPORT_IRR_ANIM_FPS :: "IMPORT_IRR_ANIM_FPS";

AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE :: "IMPORT_OGRE_MATERIAL_FILE";

AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME :: "IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME";

AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT :: "AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT";

AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS :: "IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS";

AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION :: "IMPORT_IFC_CUSTOM_TRIANGULATION";

AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE :: "IMPORT_IFC_SMOOTHING_ANGLE";

AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE :: 10.0;

AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION :: "IMPORT_IFC_CYLINDRICAL_TESSELLATION";

AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION :: 32;

AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION :: "IMPORT_COLLADA_IGNORE_UP_DIRECTION";

AI_CONFIG_IMPORT_COLLADA_IGNORE_UNIT_SIZE :: "IMPORT_COLLADA_IGNORE_UNIT_SIZE";

AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES :: "IMPORT_COLLADA_USE_COLLADA_NAMES";

AI_CONFIG_EXPORT_XFILE_64BIT :: "EXPORT_XFILE_64BIT";

AI_CONFIG_EXPORT_POINT_CLOUDS :: "EXPORT_POINT_CLOUDS";

AI_CONFIG_USE_GLTF_PBR_SPECULAR_GLOSSINESS :: "USE_GLTF_PBR_SPECULAR_GLOSSINESS";

AI_CONFIG_EXPORT_GLTF_UNLIMITED_SKINNING_BONES_PER_VERTEX :: "USE_UNLIMITED_BONES_PER VERTEX";

AI_CONFIG_EXPORT_FBX_TRANSPARENCY_FACTOR_REFER_TO_OPACITY :: "EXPORT_FBX_TRANSPARENCY_FACTOR_REFER_TO_OPACITY";

AI_CONFIG_EXPORT_BLOB_NAME :: "EXPORT_BLOB_NAME";

AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY :: "GLOBAL_SCALE_FACTOR";

AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT :: 1.0;

AI_CONFIG_APP_SCALE_KEY :: "APP_SCALE_FACTOR";

SIZE_MAX :: ~(cast(u64) 0);

ASSIMP_AI_REAL_TEXT_PRECISION :: 9;

AI_MATH_PI :: 3.141592653589793238462643383279;
AI_MATH_TWO_PI :: AI_MATH_PI * 2.0;
AI_MATH_HALF_PI :: AI_MATH_PI * 0.5;

AI_MATH_PI_F :: 3.1415926538;
AI_MATH_TWO_PI_F :: AI_MATH_PI_F * 2.0;
AI_MATH_HALF_PI_F :: AI_MATH_PI_F * 0.5;

ai_epsilon :: cast(ai_real) 1.0e-6;

AI_MAXLEN :: 1024;

AI_EMBEDDED_TEXNAME_PREFIX :: "*";

HINTMAXTEXTURELEN :: 9;

AI_MAX_FACE_INDICES :: 0x7fff;

AI_MAX_BONE_WEIGHTS :: 0x7fffffff;

AI_MAX_VERTICES :: 0x7fffffff;

AI_MAX_FACES :: 0x7fffffff;

AI_MAX_NUMBER_OF_COLOR_SETS :: 0x8;

AI_MAX_NUMBER_OF_TEXTURECOORDS :: 0x8;

AI_DEFAULT_MATERIAL_NAME :: "DefaultMaterial";

_AI_MATKEY_TEXTURE_BASE :: "$tex.file";
_AI_MATKEY_UVWSRC_BASE :: "$tex.uvwsrc";
_AI_MATKEY_TEXOP_BASE :: "$tex.op";
_AI_MATKEY_MAPPING_BASE :: "$tex.mapping";
_AI_MATKEY_TEXBLEND_BASE :: "$tex.blend";
_AI_MATKEY_MAPPINGMODE_U_BASE :: "$tex.mapmodeu";
_AI_MATKEY_MAPPINGMODE_V_BASE :: "$tex.mapmodev";
_AI_MATKEY_TEXMAP_AXIS_BASE :: "$tex.mapaxis";
_AI_MATKEY_UVTRANSFORM_BASE :: "$tex.uvtrafo";
_AI_MATKEY_TEXFLAGS_BASE :: "$tex.flags";

AI_FALSE :: 0;
AI_TRUE :: 1;

AI_SCENE_FLAGS_INCOMPLETE :: 0x1;

AI_SCENE_FLAGS_VALIDATED :: 0x2;

AI_SCENE_FLAGS_VALIDATION_WARNING :: 0x4;

AI_SCENE_FLAGS_NON_VERBOSE_FORMAT :: 0x8;

AI_SCENE_FLAGS_TERRAIN :: 0x10;

AI_SCENE_FLAGS_ALLOW_SHARED :: 0x20;

// ---------------------------------------------------------------------------
/** @brief Enumerates components of the aiScene and aiMesh data structures
*  that can be excluded from the import using the #aiProcess_RemoveComponent step.
*
*  See the documentation to #aiProcess_RemoveComponent for more details.
*/
aiComponent :: enum s32 {
    NORMALS                 :: 2;

    TANGENTS_AND_BITANGENTS :: 4;

    COLORS                  :: 8;

    TEXCOORDS               :: 16;

    BONEWEIGHTS             :: 32;

    ANIMATIONS              :: 64;

    TEXTURES                :: 128;

    LIGHTS                  :: 256;

    CAMERAS                 :: 512;

    MESHES                  :: 1024;

    MATERIALS               :: 2048;

    aiComponent_Force32Bit  :: -1610612737;

    aiComponent_NORMALS                 :: NORMALS;

    aiComponent_TANGENTS_AND_BITANGENTS :: TANGENTS_AND_BITANGENTS;

    aiComponent_COLORS                  :: COLORS;

    aiComponent_TEXCOORDS               :: TEXCOORDS;

    aiComponent_BONEWEIGHTS             :: BONEWEIGHTS;

    aiComponent_ANIMATIONS              :: ANIMATIONS;

    aiComponent_TEXTURES                :: TEXTURES;

    aiComponent_LIGHTS                  :: LIGHTS;

    aiComponent_CAMERAS                 :: CAMERAS;

    aiComponent_MESHES                  :: MESHES;

    aiComponent_MATERIALS               :: MATERIALS;

    _aiComponent_Force32Bit             :: aiComponent_Force32Bit;
}

ai_real :: float;
ai_int :: s32;
ai_uint :: u32;

aiVector2D :: struct {
    x: ai_real;
    y: ai_real;
}

aiVector3D :: struct {
    x: ai_real;
    y: ai_real;
    z: ai_real;
}

aiColor4D :: struct {
    r: float;
    g: float;
    b: float;
    a: float;
}

aiMatrix3x3 :: struct {
    a1: ai_real;
    a2: ai_real;
    a3: ai_real;
    b1: ai_real;
    b2: ai_real;
    b3: ai_real;
    c1: ai_real;
    c2: ai_real;
    c3: ai_real;
}

aiMatrix4x4 :: struct {
    a1: ai_real;
    a2: ai_real;
    a3: ai_real;
    a4: ai_real;
    b1: ai_real;
    b2: ai_real;
    b3: ai_real;
    b4: ai_real;
    c1: ai_real;
    c2: ai_real;
    c3: ai_real;
    c4: ai_real;
    d1: ai_real;
    d2: ai_real;
    d3: ai_real;
    d4: ai_real;
}

aiQuaternion :: struct {
    w: ai_real;
    x: ai_real;
    y: ai_real;
    z: ai_real;
}

ai_int32 :: s32;
ai_uint32 :: u32;

// ----------------------------------------------------------------------------------
/** Represents a plane in a three-dimensional, euclidean space
*/
aiPlane :: struct {
    //! Plane equation
    a: ai_real;
    //! Plane equation
    b: ai_real;
    //! Plane equation
    c: ai_real;
    //! Plane equation
    d: ai_real;
}

// ----------------------------------------------------------------------------------
/** Represents a ray
*/
aiRay :: struct {
    //! Position and direction of the ray
    pos: aiVector3D;
    //! Position and direction of the ray
    dir: aiVector3D;
}

// ----------------------------------------------------------------------------------
/** Represents a color in Red-Green-Blue space.
*/
aiColor3D :: struct {
    //! Red, green and blue color values
    r: float;
    //! Red, green and blue color values
    g: float;
    //! Red, green and blue color values
    b: float;
}

// ----------------------------------------------------------------------------------
/**
* @brief Represents an UTF-8 string, zero byte terminated.
*
*  The character set of an aiString is explicitly defined to be UTF-8. This Unicode
*  transformation was chosen in the belief that most strings in 3d files are limited
*  to ASCII, thus the character set needed to be strictly ASCII compatible.
*
*  Most text file loaders provide proper Unicode input file handling, special unicode
*  characters are correctly transcoded to UTF8 and are kept throughout the libraries'
*  import pipeline.
*
*  For most applications, it will be absolutely sufficient to interpret the
*  aiString as ASCII data and work with it as one would work with a plain char*.
*  Windows users in need of proper support for i.e asian characters can use the
*  MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the
*  UTF-8 strings to their working character set (i.e. MBCS, WideChar).
*
*  We use this representation instead of std::string to be C-compatible. The
*  (binary) length of such a string is limited to AI_MAXLEN characters (including the
*  the terminating zero).
*/
aiString :: struct {
    /** Binary length of the string excluding the terminal 0. This is NOT the
    *  logical length of strings containing UTF-8 multi-byte sequences! It's
    *  the number of bytes from the beginning of the string to its end.*/
    length: ai_uint32;

    /** String buffer. Size limit is AI_MAXLEN */
    data:   [1024] u8;
}

// ----------------------------------------------------------------------------------
/** Standard return type for some library functions.
* Rarely used, and if, mostly in the C API.
*/
aiReturn :: enum s32 {
    SUCCESS              :: 0;

    FAILURE              :: -1;

    OUTOFMEMORY          :: -3;

    AI_ENFORCE_ENUM_SIZE :: 2147483647;

    aiReturn_SUCCESS      :: SUCCESS;

    aiReturn_FAILURE      :: FAILURE;

    aiReturn_OUTOFMEMORY  :: OUTOFMEMORY;

    _AI_ENFORCE_ENUM_SIZE :: AI_ENFORCE_ENUM_SIZE;
}

// ----------------------------------------------------------------------------------
/** Seek origins (for the virtual file system API).
*  Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.
*/
aiOrigin :: enum s32 {
    SET                         :: 0;

    CUR                         :: 1;

    END                         :: 2;

    AI_ORIGIN_ENFORCE_ENUM_SIZE :: 2147483647;

    aiOrigin_SET                 :: SET;

    aiOrigin_CUR                 :: CUR;

    aiOrigin_END                 :: END;

    _AI_ORIGIN_ENFORCE_ENUM_SIZE :: AI_ORIGIN_ENFORCE_ENUM_SIZE;
}

// ----------------------------------------------------------------------------------
/** @brief Enumerates predefined log streaming destinations.
*  Logging to these streams can be enabled with a single call to
*   #LogStream::createDefaultStream.
*/
aiDefaultLogStream :: enum s32 {
    FILE                     :: 1;

    STDOUT                   :: 2;

    STDERR                   :: 4;

    DEBUGGER                 :: 8;

    AI_DLS_ENFORCE_ENUM_SIZE :: 2147483647;

    aiDefaultLogStream_FILE     :: FILE;

    aiDefaultLogStream_STDOUT   :: STDOUT;

    aiDefaultLogStream_STDERR   :: STDERR;

    aiDefaultLogStream_DEBUGGER :: DEBUGGER;

    _AI_DLS_ENFORCE_ENUM_SIZE   :: AI_DLS_ENFORCE_ENUM_SIZE;
}

// ----------------------------------------------------------------------------------
/** Stores the memory requirements for different components (e.g. meshes, materials,
*  animations) of an import. All sizes are in bytes.
*  @see Importer::GetMemoryRequirements()
*/
aiMemoryInfo :: struct {
    /** Storage allocated for texture data */
    textures:   u32;

    /** Storage allocated for material data  */
    materials:  u32;

    /** Storage allocated for mesh data */
    meshes:     u32;

    /** Storage allocated for node data */
    nodes:      u32;

    /** Storage allocated for animation data */
    animations: u32;

    /** Storage allocated for camera data */
    cameras:    u32;

    /** Storage allocated for light data */
    lights:     u32;

    /** Total storage allocated for the full import. */
    total:      u32;
}

/**
*  @brief  Type to store a in-memory data buffer.
*/
aiBuffer :: struct {
    data: *u8; ///< Begin poiner
    end:  *u8; ///< End pointer
}

// --------------------------------------------------------------------------------
/** @brief Helper structure to represent a texel in a ARGB8888 format
*
*  Used by aiTexture.
*/
aiTexel :: struct {
    b: u8;
    g: u8;
    r: u8;
    a: u8;
}

// --------------------------------------------------------------------------------
/** Helper structure to describe an embedded texture
*
* Normally textures are contained in external files but some file formats embed
* them directly in the model file. There are two types of embedded textures:
* 1. Uncompressed textures. The color data is given in an uncompressed format.
* 2. Compressed textures stored in a file format like png or jpg. The raw file
* bytes are given so the application must utilize an image decoder (e.g. DevIL) to
* get access to the actual color data.
*
* Embedded textures are referenced from materials using strings like "*0", "*1", etc.
* as the texture paths (a single asterisk character followed by the
* zero-based index of the texture in the aiScene::mTextures array).
*/
aiTexture :: struct {
    /** Width of the texture, in pixels
    *
    * If mHeight is zero the texture is compressed in a format
    * like JPEG. In this case mWidth specifies the size of the
    * memory area pcData is pointing to, in bytes.
    */
    mWidth:        u32;

    /** Height of the texture, in pixels
    *
    * If this value is zero, pcData points to an compressed texture
    * in any format (e.g. JPEG).
    */
    mHeight:       u32;

    achFormatHint: [9] u8; // 8 for string + 1 for terminator.

    /** Data of the texture.
    *
    * Points to an array of mWidth * mHeight aiTexel's.
    * The format of the texture data is always ARGB8888 to
    * make the implementation for user of the library as easy
    * as possible. If mHeight = 0 this is a pointer to a memory
    * buffer of size mWidth containing the compressed texture
    * data. Good luck, have fun!
    */
    pcData:        *aiTexel;

    /** Texture original filename
    *
    * Used to get the texture reference
    */
    mFilename:     aiString;
}

// ---------------------------------------------------------------------------
/**
*  An axis-aligned bounding box.
*/
aiAABB :: struct {
    mMin: aiVector3D;
    mMax: aiVector3D;
}

// ---------------------------------------------------------------------------
/**
* @brief A single face in a mesh, referring to multiple vertices.
*
* If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3
* it's called 'polygon' (hey, that's just a definition!).
* <br>
* aiMesh::mPrimitiveTypes can be queried to quickly examine which types of
* primitive are actually present in a mesh. The #aiProcess_SortByPType flag
* executes a special post-processing algorithm which splits meshes with
* *different* primitive types mixed up (e.g. lines and triangles) in several
* 'clean' sub-meshes. Furthermore there is a configuration option (
* #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove
* specific kinds of primitives from the imported scene, completely and forever.
* In many cases you'll probably want to set this setting to
* @code
* aiPrimitiveType_LINE|aiPrimitiveType_POINT
* @endcode
* Together with the #aiProcess_Triangulate flag you can then be sure that
* #aiFace::mNumIndices is always 3.
* @note Take a look at the @link data Data Structures page @endlink for
* more information on the layout and winding order of a face.
*/
aiFace :: struct {
    //! Number of indices defining this face.
    //! The maximum value for this member is #AI_MAX_FACE_INDICES.
    mNumIndices: u32;

    //! Pointer to the indices array. Size of the array is given in numIndices.
    mIndices:    *u32;
}

// ---------------------------------------------------------------------------
/** @brief A single influence of a bone on a vertex.
*/
aiVertexWeight :: struct {
    //! Index of the vertex which is influenced by the bone.
    mVertexId: u32;

    //! The strength of the influence in the range (0...1).
    //! The influence from all bones at one vertex amounts to 1.
    mWeight:   ai_real;
}

// ---------------------------------------------------------------------------
/** @brief A single bone of a mesh.
*
*  A bone has a name by which it can be found in the frame hierarchy and by
*  which it can be addressed by animations. In addition it has a number of
*  influences on vertices, and a matrix relating the mesh position to the
*  position of the bone at the time of binding.
*/
aiBone :: struct {
    /**
    * The name of the bone.
    */
    mName:         aiString;

    /**
    * The number of vertices affected by this bone.
    * The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
    */
    mNumWeights:   u32;

    /**
    * The bone armature node - used for skeleton conversion
    * you must enable aiProcess_PopulateArmatureData to populate this
    */
    mArmature:     *aiNode;

    /**
    * The bone node in the scene - used for skeleton conversion
    * you must enable aiProcess_PopulateArmatureData to populate this
    */
    mNode:         *aiNode;

    /**
    * The influence weights of this bone, by vertex index.
    */
    mWeights:      *aiVertexWeight;

    /**
    * Matrix that transforms from mesh space to bone space in bind pose.
    *
    * This matrix describes the position of the mesh
    * in the local space of this bone when the skeleton was bound.
    * Thus it can be used directly to determine a desired vertex position,
    * given the world-space transform of the bone when animated,
    * and the position of the vertex in mesh space.
    *
    * It is sometimes called an inverse-bind matrix,
    * or inverse bind pose matrix.
    */
    mOffsetMatrix: aiMatrix4x4;
}

// ---------------------------------------------------------------------------
/** @brief Enumerates the types of geometric primitives supported by Assimp.
*
*  @see aiFace Face data structure
*  @see aiProcess_SortByPType Per-primitive sorting of meshes
*  @see aiProcess_Triangulate Automatic triangulation
*  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
*/
aiPrimitiveType :: enum s32 {
    POINT                      :: 1;

    LINE                       :: 2;

    TRIANGLE                   :: 4;

    POLYGON                    :: 8;

    NGONEncodingFlag           :: 16;

    aiPrimitiveType_Force32Bit :: 2147483647;

    aiPrimitiveType_POINT            :: POINT;

    aiPrimitiveType_LINE             :: LINE;

    aiPrimitiveType_TRIANGLE         :: TRIANGLE;

    aiPrimitiveType_POLYGON          :: POLYGON;

    aiPrimitiveType_NGONEncodingFlag :: NGONEncodingFlag;

    _aiPrimitiveType_Force32Bit      :: aiPrimitiveType_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
*  animations for a particular frame.
*
*  You may think of an #aiAnimMesh as a `patch` for the host mesh, which
*  replaces only certain vertex data streams at a particular time.
*  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
*  The actual relationship between the time line and anim meshes is
*  established by #aiMeshAnim, which references singular mesh attachments
*  by their ID and binds them to a time offset.
*/
aiAnimMesh :: struct {
    /**Anim Mesh name */
    mName:          aiString;

    /** Replacement for aiMesh::mVertices. If this array is non-nullptr,
    *  it *must* contain mNumVertices entries. The corresponding
    *  array in the host mesh must be non-nullptr as well - animation
    *  meshes may neither add or nor remove vertex components (if
    *  a replacement array is nullptr and the corresponding source
    *  array is not, the source data is taken instead)*/
    mVertices:      *aiVector3D;

    /** Replacement for aiMesh::mNormals.  */
    mNormals:       *aiVector3D;

    /** Replacement for aiMesh::mTangents. */
    mTangents:      *aiVector3D;

    /** Replacement for aiMesh::mBitangents. */
    mBitangents:    *aiVector3D;

    /** Replacement for aiMesh::mColors */
    mColors:        [8] *aiColor4D;

    /** Replacement for aiMesh::mTextureCoords */
    mTextureCoords: [8] *aiVector3D;

    /** The number of vertices in the aiAnimMesh, and thus the length of all
    * the member arrays.
    *
    * This has always the same value as the mNumVertices property in the
    * corresponding aiMesh. It is duplicated here merely to make the length
    * of the member arrays accessible even if the aiMesh is not known, e.g.
    * from language bindings.
    */
    mNumVertices:   u32;

    /**
    * Weight of the AnimMesh.
    */
    mWeight:        float;
}

// ---------------------------------------------------------------------------
/** @brief Enumerates the methods of mesh morphing supported by Assimp.
*/
aiMorphingMethod :: enum s32 {
    UNKNOWN                     :: 0;

    VERTEX_BLEND                :: 1;

    MORPH_NORMALIZED            :: 2;

    MORPH_RELATIVE              :: 3;

    aiMorphingMethod_Force32Bit :: 2147483647;

    aiMorphingMethod_UNKNOWN          :: UNKNOWN;

    aiMorphingMethod_VERTEX_BLEND     :: VERTEX_BLEND;

    aiMorphingMethod_MORPH_NORMALIZED :: MORPH_NORMALIZED;

    aiMorphingMethod_MORPH_RELATIVE   :: MORPH_RELATIVE;

    _aiMorphingMethod_Force32Bit      :: aiMorphingMethod_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief A mesh represents a geometry or model with a single material.
*
* It usually consists of a number of vertices and a series of primitives/faces
* referencing the vertices. In addition there might be a series of bones, each
* of them addressing a number of vertices with a certain weight. Vertex data
* is presented in channels with each channel containing a single per-vertex
* information such as a set of texture coordinates or a normal vector.
* If a data pointer is non-null, the corresponding data stream is present.
* From C++-programs you can also use the comfort functions Has*() to
* test for the presence of various data streams.
*
* A Mesh uses only a single material which is referenced by a material ID.
* @note The mPositions member is usually not optional. However, vertex positions
* *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in
* @code
* aiScene::mFlags
* @endcode
*/
aiMesh :: struct {
    /**
    * Bitwise combination of the members of the #aiPrimitiveType enum.
    * This specifies which types of primitives are present in the mesh.
    * The "SortByPrimitiveType"-Step can be used to make sure the
    * output meshes consist of one primitive type each.
    */
    mPrimitiveTypes:     u32;

    /**
    * The number of vertices in this mesh.
    * This is also the size of all of the per-vertex data arrays.
    * The maximum value for this member is #AI_MAX_VERTICES.
    */
    mNumVertices:        u32;

    /**
    * The number of primitives (triangles, polygons, lines) in this  mesh.
    * This is also the size of the mFaces array.
    * The maximum value for this member is #AI_MAX_FACES.
    */
    mNumFaces:           u32;

    /**
    * @brief Vertex positions.
    *
    * This array is always present in a mesh. The array is
    * mNumVertices in size.
    */
    mVertices:           *aiVector3D;

    /**
    * @brief Vertex normals.
    *
    * The array contains normalized vectors, nullptr if not present.
    * The array is mNumVertices in size. Normals are undefined for
    * point and line primitives. A mesh consisting of points and
    * lines only may not have normal vectors. Meshes with mixed
    * primitive types (i.e. lines and triangles) may have normals,
    * but the normals for vertices that are only referenced by
    * point or line primitives are undefined and set to QNaN (WARN:
    * qNaN compares to inequal to *everything*, even to qNaN itself.
    * Using code like this to check whether a field is qnan is:
    * @code
    * #define IS_QNAN(f) (f != f)
    * @endcode
    * still dangerous because even 1.f == 1.f could evaluate to false! (
    * remember the subtleties of IEEE754 artithmetics). Use stuff like
    * @c fpclassify instead.
    * @note Normal vectors computed by Assimp are always unit-length.
    * However, this needn't apply for normals that have been taken
    * directly from the model file.
    */
    mNormals:            *aiVector3D;

    /**
    * @brief Vertex tangents.
    *
    * The tangent of a vertex points in the direction of the positive
    * X texture axis. The array contains normalized vectors, nullptr if
    * not present. The array is mNumVertices in size. A mesh consisting
    * of points and lines only may not have normal vectors. Meshes with
    * mixed primitive types (i.e. lines and triangles) may have
    * normals, but the normals for vertices that are only referenced by
    * point or line primitives are undefined and set to qNaN.  See
    * the #mNormals member for a detailed discussion of qNaNs.
    * @note If the mesh contains tangents, it automatically also
    * contains bitangents.
    */
    mTangents:           *aiVector3D;

    /**
    * @brief Vertex bitangents.
    *
    * The bitangent of a vertex points in the direction of the positive
    * Y texture axis. The array contains normalized vectors, nullptr if not
    * present. The array is mNumVertices in size.
    * @note If the mesh contains tangents, it automatically also contains
    * bitangents.
    */
    mBitangents:         *aiVector3D;

    /**
    * @brief Vertex color sets.
    *
    * A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex
    * colors per vertex. nullptr if not present. Each array is
    * mNumVertices in size if present.
    */
    mColors:             [8] *aiColor4D;

    /**
    * @brief Vertex texture coordinates, also known as UV channels.
    *
    * A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS channels per
    * vertex. Used and unused (nullptr) channels may go in any order.
    * The array is mNumVertices in size.
    */
    mTextureCoords:      [8] *aiVector3D;

    /**
    * @brief Specifies the number of components for a given UV channel.
    *
    * Up to three channels are supported (UVW, for accessing volume
    * or cube maps). If the value is 2 for a given channel n, the
    * component p.z of mTextureCoords[n][p] is set to 0.0f.
    * If the value is 1 for a given channel, p.y is set to 0.0f, too.
    * @note 4D coordinates are not supported
    */
    mNumUVComponents:    [8] u32;

    /**
    * @brief The faces the mesh is constructed from.
    *
    * Each face refers to a number of vertices by their indices.
    * This array is always present in a mesh, its size is given
    *  in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
    * is NOT set each face references an unique set of vertices.
    */
    mFaces:              *aiFace;

    /**
    * The number of bones this mesh contains. Can be 0, in which case the mBones array is nullptr.
    */
    mNumBones:           u32;

    /**
    * @brief The bones of this mesh.
    *
    * A bone consists of a name by which it can be found in the
    * frame hierarchy and a set of vertex weights.
    */
    mBones:              **aiBone;

    /**
    * @brief The material used by this mesh.
    *
    * A mesh uses only a single material. If an imported model uses
    * multiple materials, the import splits up the mesh. Use this value
    * as index into the scene's material list.
    */
    mMaterialIndex:      u32;

    /**
    *  Name of the mesh. Meshes can be named, but this is not a
    *  requirement and leaving this field empty is totally fine.
    *  There are mainly three uses for mesh names:
    *   - some formats name nodes and meshes independently.
    *   - importers tend to split meshes up to meet the
    *      one-material-per-mesh requirement. Assigning
    *      the same (dummy) name to each of the result meshes
    *      aids the caller at recovering the original mesh
    *      partitioning.
    *   - Vertex animations refer to meshes by their names.
    */
    mName:               aiString;

    /**
    * The number of attachment meshes.
    * Currently known to work with loaders:
    * - Collada
    * - gltf
    */
    mNumAnimMeshes:      u32;

    /**
    * Attachment meshes for this mesh, for vertex-based animation.
    * Attachment meshes carry replacement data for some of the
    * mesh'es vertex components (usually positions, normals).
    * Currently known to work with loaders:
    * - Collada
    * - gltf
    */
    mAnimMeshes:         **aiAnimMesh;

    /**
    *  Method of morphing when anim-meshes are specified.
    *  @see aiMorphingMethod to learn more about the provided morphing targets.
    */
    mMethod:             aiMorphingMethod;

    /**
    *  The bounding box.
    */
    mAABB:               aiAABB;

    /**
    * Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS
    */
    mTextureCoordsNames: **aiString;
}

/**
* @brief  A skeleton bone represents a single bone is a skeleton structure.
*
* Skeleton-Animations can be represented via a skeleton struct, which describes
* a hierarchical tree assembled from skeleton bones. A bone is linked to a mesh.
* The bone knows its parent bone. If there is no parent bone the parent id is
* marked with -1.
* The skeleton-bone stores a pointer to its used armature. If there is no
* armature this value if set to nullptr.
* A skeleton bone stores its offset-matrix, which is the absolute transformation
* for the bone. The bone stores the locale transformation to its parent as well.
* You can compute the offset matrix by multiplying the hierarchy like:
* Tree: s1 -> s2 -> s3
* Offset-Matrix s3 = locale-s3 * locale-s2 * locale-s1
*/
aiSkeletonBone :: struct {
    /// The parent bone index, is -1 one if this bone represents the root bone.
    mParent:       s32;

    /// @brief The bone armature node - used for skeleton conversion
    /// you must enable aiProcess_PopulateArmatureData to populate this
    mArmature:     *aiNode;

    /// @brief The bone node in the scene - used for skeleton conversion
    /// you must enable aiProcess_PopulateArmatureData to populate this
    mNode:         *aiNode;

    /// @brief The number of weights
    mNumnWeights:  u32;

    /// The mesh index, which will get influenced by the weight.
    mMeshId:       *aiMesh;

    /// The influence weights of this bone, by vertex index.
    mWeights:      *aiVertexWeight;

    /** Matrix that transforms from bone space to mesh space in bind pose.
    *
    * This matrix describes the position of the mesh
    * in the local space of this bone when the skeleton was bound.
    * Thus it can be used directly to determine a desired vertex position,
    * given the world-space transform of the bone when animated,
    * and the position of the vertex in mesh space.
    *
    * It is sometimes called an inverse-bind matrix,
    * or inverse bind pose matrix.
    */
    mOffsetMatrix: aiMatrix4x4;

    /// Matrix that transforms the locale bone in bind pose.
    mLocalMatrix:  aiMatrix4x4;
}

/**
* @brief A skeleton represents the bone hierarchy of an animation.
*
* Skeleton animations can be described as a tree of bones:
*                  root
*                    |
*                  node1
*                  /   \
*               node3  node4
* If you want to calculate the transformation of node three you need to compute the
* transformation hierarchy for the transformation chain of node3:
* root->node1->node3
* Each node is represented as a skeleton instance.
*/
aiSkeleton :: struct {
    /**
    *  @brief The name of the skeleton instance.
    */
    mName:     aiString;

    /**
    *  @brief  The number of bones in the skeleton.
    */
    mNumBones: u32;

    /**
    *  @brief The bone instance in the skeleton.
    */
    mBones:    **aiSkeletonBone;
}

// ---------------------------------------------------------------------------
/** Enumerates all supported types of light sources.
*/
aiLightSourceType :: enum s32 {
    aiLightSource_UNDEFINED   :: 0;

    aiLightSource_DIRECTIONAL :: 1;

    aiLightSource_POINT       :: 2;

    aiLightSource_SPOT        :: 3;

    aiLightSource_AMBIENT     :: 4;

    aiLightSource_AREA        :: 5;

    aiLightSource_Force32Bit  :: 2147483647;
    _aiLightSource_Force32Bit :: aiLightSource_Force32Bit;
}

// ---------------------------------------------------------------------------
/** Helper structure to describe a light source.
*
*  Assimp supports multiple sorts of light sources, including
*  directional, point and spot lights. All of them are defined with just
*  a single structure and distinguished by their parameters.
*  Note - some file formats (such as 3DS, ASE) export a "target point" -
*  the point a spot light is looking at (it can even be animated). Assimp
*  writes the target point as a sub-node of a spot-lights's main node,
*  called "<spotName>.Target". However, this is just additional information
*  then, the transformation tracks of the main node make the
*  spot light already point in the right direction.
*/
aiLight :: struct {
    /** The name of the light source.
    *
    *  There must be a node in the scene-graph with the same name.
    *  This node specifies the position of the light in the scene
    *  hierarchy and can be animated.
    */
    mName:                 aiString;

    /** The type of the light source.
    *
    * aiLightSource_UNDEFINED is not a valid value for this member.
    */
    mType:                 aiLightSourceType;

    /** Position of the light source in space. Relative to the
    *  transformation of the node corresponding to the light.
    *
    *  The position is undefined for directional lights.
    */
    mPosition:             aiVector3D;

    /** Direction of the light source in space. Relative to the
    *  transformation of the node corresponding to the light.
    *
    *  The direction is undefined for point lights. The vector
    *  may be normalized, but it needn't.
    */
    mDirection:            aiVector3D;

    /** Up direction of the light source in space. Relative to the
    *  transformation of the node corresponding to the light.
    *
    *  The direction is undefined for point lights. The vector
    *  may be normalized, but it needn't.
    */
    mUp:                   aiVector3D;

    /** Constant light attenuation factor.
    *
    *  The intensity of the light source at a given distance 'd' from
    *  the light's position is
    *  @code
    *  Atten = 1/( att0 + att1 * d + att2 * d*d)
    *  @endcode
    *  This member corresponds to the att0 variable in the equation.
    *  Naturally undefined for directional lights.
    */
    mAttenuationConstant:  float;

    /** Linear light attenuation factor.
    *
    *  The intensity of the light source at a given distance 'd' from
    *  the light's position is
    *  @code
    *  Atten = 1/( att0 + att1 * d + att2 * d*d)
    *  @endcode
    *  This member corresponds to the att1 variable in the equation.
    *  Naturally undefined for directional lights.
    */
    mAttenuationLinear:    float;

    /** Quadratic light attenuation factor.
    *
    *  The intensity of the light source at a given distance 'd' from
    *  the light's position is
    *  @code
    *  Atten = 1/( att0 + att1 * d + att2 * d*d)
    *  @endcode
    *  This member corresponds to the att2 variable in the equation.
    *  Naturally undefined for directional lights.
    */
    mAttenuationQuadratic: float;

    /** Diffuse color of the light source
    *
    *  The diffuse light color is multiplied with the diffuse
    *  material color to obtain the final color that contributes
    *  to the diffuse shading term.
    */
    mColorDiffuse:         aiColor3D;

    /** Specular color of the light source
    *
    *  The specular light color is multiplied with the specular
    *  material color to obtain the final color that contributes
    *  to the specular shading term.
    */
    mColorSpecular:        aiColor3D;

    /** Ambient color of the light source
    *
    *  The ambient light color is multiplied with the ambient
    *  material color to obtain the final color that contributes
    *  to the ambient shading term. Most renderers will ignore
    *  this value it, is just a remaining of the fixed-function pipeline
    *  that is still supported by quite many file formats.
    */
    mColorAmbient:         aiColor3D;

    /** Inner angle of a spot light's light cone.
    *
    *  The spot light has maximum influence on objects inside this
    *  angle. The angle is given in radians. It is 2PI for point
    *  lights and undefined for directional lights.
    */
    mAngleInnerCone:       float;

    /** Outer angle of a spot light's light cone.
    *
    *  The spot light does not affect objects outside this angle.
    *  The angle is given in radians. It is 2PI for point lights and
    *  undefined for directional lights. The outer angle must be
    *  greater than or equal to the inner angle.
    *  It is assumed that the application uses a smooth
    *  interpolation between the inner and the outer cone of the
    *  spot light.
    */
    mAngleOuterCone:       float;

    /** Size of area light source. */
    mSize:                 aiVector2D;
}

// ---------------------------------------------------------------------------
/** Helper structure to describe a virtual camera.
*
* Cameras have a representation in the node graph and can be animated.
* An important aspect is that the camera itself is also part of the
* scene-graph. This means, any values such as the look-at vector are not
* *absolute*, they're <b>relative</b> to the coordinate system defined
* by the node which corresponds to the camera. This allows for camera
* animations. For static cameras parameters like the 'look-at' or 'up' vectors
* are usually specified directly in aiCamera, but beware, they could also
* be encoded in the node transformation. The following (pseudo)code sample
* shows how to do it: <br><br>
* @code
* // Get the camera matrix for a camera at a specific time
* // if the node hierarchy for the camera does not contain
* // at least one animated node this is a static computation
* get-camera-matrix (node sceneRoot, camera cam) : matrix
* {
*    node   cnd = find-node-for-camera(cam)
*    matrix cmt = identity()
*
*    // as usual - get the absolute camera transformation for this frame
*    for each node nd in hierarchy from sceneRoot to cnd
*      matrix cur
*      if (is-animated(nd))
*         cur = eval-animation(nd)
*      else cur = nd->mTransformation;
*      cmt = mult-matrices( cmt, cur )
*    end for
*
*    // now multiply with the camera's own local transform
*    cam = mult-matrices (cam, get-camera-matrix(cmt) )
* }
* @endcode
*
* @note some file formats (such as 3DS, ASE) export a "target point" -
* the point the camera is looking at (it can even be animated). Assimp
* writes the target point as a subnode of the camera's main node,
* called "<camName>.Target". However this is just additional information
* then the transformation tracks of the camera main node make the
* camera already look in the right direction.
*
*/
aiCamera :: struct {
    /** The name of the camera.
    *
    *  There must be a node in the scenegraph with the same name.
    *  This node specifies the position of the camera in the scene
    *  hierarchy and can be animated.
    */
    mName:              aiString;

    /** Position of the camera relative to the coordinate space
    *  defined by the corresponding node.
    *
    *  The default value is 0|0|0.
    */
    mPosition:          aiVector3D;

    /** 'Up' - vector of the camera coordinate system relative to
    *  the coordinate space defined by the corresponding node.
    *
    *  The 'right' vector of the camera coordinate system is
    *  the cross product of  the up and lookAt vectors.
    *  The default value is 0|1|0. The vector
    *  may be normalized, but it needn't.
    */
    mUp:                aiVector3D;

    /** 'LookAt' - vector of the camera coordinate system relative to
    *  the coordinate space defined by the corresponding node.
    *
    *  This is the viewing direction of the user.
    *  The default value is 0|0|1. The vector
    *  may be normalized, but it needn't.
    */
    mLookAt:            aiVector3D;

    /** Horizontal field of view angle, in radians.
    *
    *  The field of view angle is the angle between the center
    *  line of the screen and the left or right border.
    *  The default value is 1/4PI.
    */
    mHorizontalFOV:     float;

    /** Distance of the near clipping plane from the camera.
    *
    * The value may not be 0.f (for arithmetic reasons to prevent
    * a division through zero). The default value is 0.1f.
    */
    mClipPlaneNear:     float;

    /** Distance of the far clipping plane from the camera.
    *
    * The far clipping plane must, of course, be further away than the
    * near clipping plane. The default value is 1000.f. The ratio
    * between the near and the far plane should not be too
    * large (between 1000-10000 should be ok) to avoid floating-point
    * inaccuracies which could lead to z-fighting.
    */
    mClipPlaneFar:      float;

    /** Screen aspect ratio.
    *
    * This is the ration between the width and the height of the
    * screen. Typical values are 4/3, 1/2 or 1/1. This value is
    * 0 if the aspect ratio is not defined in the source file.
    * 0 is also the default value.
    */
    mAspect:            float;

    /** Half horizontal orthographic width, in scene units.
    *
    *  The orthographic width specifies the half width of the
    *  orthographic view box. If non-zero the camera is
    *  orthographic and the mAspect should define to the
    *  ratio between the orthographic width and height
    *  and mHorizontalFOV should be set to 0.
    *  The default value is 0 (not orthographic).
    */
    mOrthographicWidth: float;
}

// ---------------------------------------------------------------------------
/** @brief Defines how the Nth texture of a specific type is combined with
*  the result of all previous layers.
*
*  Example (left: key, right: value): <br>
*  @code
*  DiffColor0     - gray
*  DiffTextureOp0 - aiTextureOpMultiply
*  DiffTexture0   - tex1.png
*  DiffTextureOp0 - aiTextureOpAdd
*  DiffTexture1   - tex2.png
*  @endcode
*  Written as equation, the final diffuse term for a specific pixel would be:
*  @code
*  diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +
*     sampleTex(DiffTexture1,UV0) * diffContrib;
*  @endcode
*  where 'diffContrib' is the intensity of the incoming light for that pixel.
*/
aiTextureOp :: enum s32 {
    Multiply               :: 0;

    Add                    :: 1;

    Subtract               :: 2;

    Divide                 :: 3;

    SmoothAdd              :: 4;

    SignedAdd              :: 5;

    aiTextureOp_Force32Bit :: 2147483647;

    aiTextureOp_Multiply    :: Multiply;

    aiTextureOp_Add         :: Add;

    aiTextureOp_Subtract    :: Subtract;

    aiTextureOp_Divide      :: Divide;

    aiTextureOp_SmoothAdd   :: SmoothAdd;

    aiTextureOp_SignedAdd   :: SignedAdd;

    _aiTextureOp_Force32Bit :: aiTextureOp_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief Defines how UV coordinates outside the [0...1] range are handled.
*
*  Commonly referred to as 'wrapping mode'.
*/
aiTextureMapMode :: enum s32 {
    Wrap                        :: 0;

    Clamp                       :: 1;

    Decal                       :: 3;

    Mirror                      :: 2;

    aiTextureMapMode_Force32Bit :: 2147483647;

    aiTextureMapMode_Wrap        :: Wrap;

    aiTextureMapMode_Clamp       :: Clamp;

    aiTextureMapMode_Decal       :: Decal;

    aiTextureMapMode_Mirror      :: Mirror;

    _aiTextureMapMode_Force32Bit :: aiTextureMapMode_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief Defines how the mapping coords for a texture are generated.
*
*  Real-time applications typically require full UV coordinates, so the use of
*  the aiProcess_GenUVCoords step is highly recommended. It generates proper
*  UV channels for non-UV mapped objects, as long as an accurate description
*  how the mapping should look like (e.g spherical) is given.
*  See the #AI_MATKEY_MAPPING property for more details.
*/
aiTextureMapping :: enum s32 {
    UV                          :: 0;

    SPHERE                      :: 1;

    CYLINDER                    :: 2;

    BOX                         :: 3;

    PLANE                       :: 4;

    OTHER                       :: 5;

    aiTextureMapping_Force32Bit :: 2147483647;

    aiTextureMapping_UV          :: UV;

    aiTextureMapping_SPHERE      :: SPHERE;

    aiTextureMapping_CYLINDER    :: CYLINDER;

    aiTextureMapping_BOX         :: BOX;

    aiTextureMapping_PLANE       :: PLANE;

    aiTextureMapping_OTHER       :: OTHER;

    _aiTextureMapping_Force32Bit :: aiTextureMapping_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief Defines the purpose of a texture
*
*  This is a very difficult topic. Different 3D packages support different
*  kinds of textures. For very common texture types, such as bumpmaps, the
*  rendering results depend on implementation details in the rendering
*  pipelines of these applications. Assimp loads all texture references from
*  the model file and tries to determine which of the predefined texture
*  types below is the best choice to match the original use of the texture
*  as closely as possible.<br>
*
*  In content pipelines you'll usually define how textures have to be handled,
*  and the artists working on models have to conform to this specification,
*  regardless which 3D tool they're using.
*/
aiTextureType :: enum s32 {
    NONE                     :: 0;

    DIFFUSE                  :: 1;

    SPECULAR                 :: 2;

    AMBIENT                  :: 3;

    EMISSIVE                 :: 4;

    HEIGHT                   :: 5;

    NORMALS                  :: 6;

    SHININESS                :: 7;

    OPACITY                  :: 8;

    DISPLACEMENT             :: 9;

    LIGHTMAP                 :: 10;

    REFLECTION               :: 11;

    BASE_COLOR               :: 12;
    NORMAL_CAMERA            :: 13;
    EMISSION_COLOR           :: 14;
    METALNESS                :: 15;
    DIFFUSE_ROUGHNESS        :: 16;
    AMBIENT_OCCLUSION        :: 17;

    UNKNOWN                  :: 18;

    SHEEN                    :: 19;

    CLEARCOAT                :: 20;

    TRANSMISSION             :: 21;

    MAYA_BASE                :: 22;
    MAYA_SPECULAR            :: 23;
    MAYA_SPECULAR_COLOR      :: 24;
    MAYA_SPECULAR_ROUGHNESS  :: 25;

    aiTextureType_Force32Bit :: 2147483647;

    aiTextureType_NONE                    :: NONE;

    aiTextureType_DIFFUSE                 :: DIFFUSE;

    aiTextureType_SPECULAR                :: SPECULAR;

    aiTextureType_AMBIENT                 :: AMBIENT;

    aiTextureType_EMISSIVE                :: EMISSIVE;

    aiTextureType_HEIGHT                  :: HEIGHT;

    aiTextureType_NORMALS                 :: NORMALS;

    aiTextureType_SHININESS               :: SHININESS;

    aiTextureType_OPACITY                 :: OPACITY;

    aiTextureType_DISPLACEMENT            :: DISPLACEMENT;

    aiTextureType_LIGHTMAP                :: LIGHTMAP;

    aiTextureType_REFLECTION              :: REFLECTION;

    aiTextureType_BASE_COLOR              :: BASE_COLOR;
    aiTextureType_NORMAL_CAMERA           :: NORMAL_CAMERA;
    aiTextureType_EMISSION_COLOR          :: EMISSION_COLOR;
    aiTextureType_METALNESS               :: METALNESS;
    aiTextureType_DIFFUSE_ROUGHNESS       :: DIFFUSE_ROUGHNESS;
    aiTextureType_AMBIENT_OCCLUSION       :: AMBIENT_OCCLUSION;

    aiTextureType_UNKNOWN                 :: UNKNOWN;

    aiTextureType_SHEEN                   :: SHEEN;

    aiTextureType_CLEARCOAT               :: CLEARCOAT;

    aiTextureType_TRANSMISSION            :: TRANSMISSION;

    aiTextureType_MAYA_BASE               :: MAYA_BASE;
    aiTextureType_MAYA_SPECULAR           :: MAYA_SPECULAR;
    aiTextureType_MAYA_SPECULAR_COLOR     :: MAYA_SPECULAR_COLOR;
    aiTextureType_MAYA_SPECULAR_ROUGHNESS :: MAYA_SPECULAR_ROUGHNESS;

    _aiTextureType_Force32Bit             :: aiTextureType_Force32Bit;
}

// -------------------------------------------------------------------------------
/**
* @brief  Get a string for a given aiTextureType
*
* @param  in  The texture type
* @return The description string for the texture type.
*/
aiTextureTypeToString :: (in: aiTextureType) -> *u8 #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Defines all shading models supported by the library
*
*  Property: #AI_MATKEY_SHADING_MODEL
*
*  The list of shading modes has been taken from Blender.
*  See Blender documentation for more information. The API does
*  not distinguish between "specular" and "diffuse" shaders (thus the
*  specular term for diffuse shading models like Oren-Nayar remains
*  undefined). <br>
*  Again, this value is just a hint. Assimp tries to select the shader whose
*  most common implementation matches the original rendering results of the
*  3D modeler which wrote a particular model as closely as possible.
*
*/
aiShadingMode :: enum s32 {
    Flat                     :: 1;

    Gouraud                  :: 2;

    Phong                    :: 3;

    Blinn                    :: 4;

    Toon                     :: 5;

    OrenNayar                :: 6;

    Minnaert                 :: 7;

    CookTorrance             :: 8;

    NoShading                :: 9;
    Unlit                    :: 9;

    Fresnel                  :: 10;

    PBR_BRDF                 :: 11;

    aiShadingMode_Force32Bit :: 2147483647;

    aiShadingMode_Flat         :: Flat;

    aiShadingMode_Gouraud      :: Gouraud;

    aiShadingMode_Phong        :: Phong;

    aiShadingMode_Blinn        :: Blinn;

    aiShadingMode_Toon         :: Toon;

    aiShadingMode_OrenNayar    :: OrenNayar;

    aiShadingMode_Minnaert     :: Minnaert;

    aiShadingMode_CookTorrance :: CookTorrance;

    aiShadingMode_NoShading    :: NoShading;
    aiShadingMode_Unlit        :: Unlit;

    aiShadingMode_Fresnel      :: Fresnel;

    aiShadingMode_PBR_BRDF     :: PBR_BRDF;

    _aiShadingMode_Force32Bit  :: aiShadingMode_Force32Bit;
}

// ---------------------------------------------------------------------------
/**
*  @brief Defines some mixed flags for a particular texture.
*
*  Usually you'll instruct your cg artists how textures have to look like ...
*  and how they will be processed in your application. However, if you use
*  Assimp for completely generic loading purposes you might also need to
*  process these flags in order to display as many 'unknown' 3D models as
*  possible correctly.
*
*  This corresponds to the #AI_MATKEY_TEXFLAGS property.
*/
aiTextureFlags :: enum s32 {
    Invert                    :: 1;

    UseAlpha                  :: 2;

    IgnoreAlpha               :: 4;

    aiTextureFlags_Force32Bit :: 2147483647;

    aiTextureFlags_Invert      :: Invert;

    aiTextureFlags_UseAlpha    :: UseAlpha;

    aiTextureFlags_IgnoreAlpha :: IgnoreAlpha;

    _aiTextureFlags_Force32Bit :: aiTextureFlags_Force32Bit;
}

// ---------------------------------------------------------------------------
/**
*  @brief Defines alpha-blend flags.
*
*  If you're familiar with OpenGL or D3D, these flags aren't new to you.
*  They define *how* the final color value of a pixel is computed, basing
*  on the previous color at that pixel and the new color value from the
*  material.
*  The blend formula is:
*  @code
*    SourceColor * SourceBlend + DestColor * DestBlend
*  @endcode
*  where DestColor is the previous color in the frame-buffer at this
*  position and SourceColor is the material color before the transparency
*  calculation.<br>
*  This corresponds to the #AI_MATKEY_BLEND_FUNC property.
*/
aiBlendMode :: enum s32 {
    Default                :: 0;

    Additive               :: 1;

    aiBlendMode_Force32Bit :: 2147483647;

    aiBlendMode_Default     :: Default;

    aiBlendMode_Additive    :: Additive;

    _aiBlendMode_Force32Bit :: aiBlendMode_Force32Bit;
}

// ---------------------------------------------------------------------------
/**
*  @brief Defines how an UV channel is transformed.
*
*  This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
*  See its documentation for more details.
*
*  Typically you'll want to build a matrix of this information. However,
*  we keep separate scaling/translation/rotation values to make it
*  easier to process and optimize UV transformations internally.
*/
aiUVTransform :: struct {
    /** Translation on the u and v axes.
    *
    *  The default value is (0|0).
    */
    mTranslation: aiVector2D;

    /** Scaling on the u and v axes.
    *
    *  The default value is (1|1).
    */
    mScaling:     aiVector2D;

    /** Rotation - in counter-clockwise direction.
    *
    *  The rotation angle is specified in radians. The
    *  rotation center is 0.5f|0.5f. The default value
    *  0.f.
    */
    mRotation:    ai_real;
}

//! @cond AI_DOX_INCLUDE_INTERNAL
// ---------------------------------------------------------------------------
/**
*  @brief A very primitive RTTI system for the contents of material properties.
*/
aiPropertyTypeInfo :: enum s32 {
    aiPTI_Float      :: 1;

    aiPTI_Double     :: 2;

    aiPTI_String     :: 3;

    aiPTI_Integer    :: 4;

    aiPTI_Buffer     :: 5;

    aiPTI_Force32Bit :: 2147483647;
    _aiPTI_Force32Bit :: aiPTI_Force32Bit;
}

// ---------------------------------------------------------------------------
/** @brief Data structure for a single material property
*
*  As an user, you'll probably never need to deal with this data structure.
*  Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family
*  of functions to query material properties easily. Processing them
*  manually is faster, but it is not the recommended way. It isn't worth
*  the effort. <br>
*  Material property names follow a simple scheme:
*  @code
*    $<name>
*    ?<name>
*       A public property, there must be corresponding AI_MATKEY_XXX define
*       2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials
*       post-processing step.
*    ~<name>
*       A temporary property for internal use.
*  @endcode
*  @see aiMaterial
*/
aiMaterialProperty :: struct {
    /** Specifies the name of the property (key)
    *  Keys are generally case insensitive.
    */
    mKey:        aiString;

    /** Textures: Specifies their exact usage semantic.
    * For non-texture properties, this member is always 0
    * (or, better-said, #aiTextureType_NONE).
    */
    mSemantic:   u32;

    /** Textures: Specifies the index of the texture.
    *  For non-texture properties, this member is always 0.
    */
    mIndex:      u32;

    /** Size of the buffer mData is pointing to, in bytes.
    *  This value may not be 0.
    */
    mDataLength: u32;

    /** Type information for the property.
    *
    * Defines the data layout inside the data buffer. This is used
    * by the library internally to perform debug checks and to
    * utilize proper type conversions.
    * (It's probably a hacky solution, but it works.)
    */
    mType:       aiPropertyTypeInfo;

    /** Binary buffer to hold the property's value.
    * The size of the buffer is always mDataLength.
    */
    mData:       *u8;
}

aiMaterial :: struct {
    /** List of all material properties loaded. */
    mProperties:    **aiMaterialProperty;

    /** Number of properties in the data base */
    mNumProperties: u32;

    /** Storage allocated */
    mNumAllocated:  u32;
}

//! @endcond
//!
// ---------------------------------------------------------------------------
/** @brief Retrieve a material property with a specific key from the material
*
* @param pMat Pointer to the input material. May not be NULL
* @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
* @param type Specifies the type of the texture to be retrieved (
*    e.g. diffuse, specular, height map ...)
* @param index Index of the texture to be retrieved.
* @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
*        structure or NULL if the key has not been found. */
// ---------------------------------------------------------------------------
aiGetMaterialProperty :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pPropOut: **aiMaterialProperty) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Retrieve an array of float values with a specific key
*  from the material
*
* Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
* example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)
* @code
* aiUVTransform trafo;
* unsigned int max = sizeof(aiUVTransform);
* if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),
*    (float*)&trafo, &max) || sizeof(aiUVTransform) != max)
* {
*   // error handling
* }
* @endcode
*
* @param pMat Pointer to the input material. May not be NULL
* @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
* @param pOut Pointer to a buffer to receive the result.
* @param pMax Specifies the size of the given buffer, in float's.
*        Receives the number of values (not bytes!) read.
* @param type (see the code sample above)
* @param index (see the code sample above)
* @return Specifies whether the key has been found. If not, the output
*   arrays remains unmodified and pMax is set to 0.*/
// ---------------------------------------------------------------------------
aiGetMaterialFloatArray :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pOut: *float, pMax: *u32) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Retrieve an array of integer values with a specific key
*  from a material
*
* See the sample for aiGetMaterialFloatArray for more information.*/
aiGetMaterialIntegerArray :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pOut: *s32, pMax: *u32) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Retrieve a color value from the material property table
*
* See the sample for aiGetMaterialFloat for more information*/
// ---------------------------------------------------------------------------
aiGetMaterialColor :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pOut: *aiColor4D) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Retrieve a aiUVTransform value from the material property table
*
* See the sample for aiGetMaterialFloat for more information*/
// ---------------------------------------------------------------------------
aiGetMaterialUVTransform :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pOut: *aiUVTransform) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** @brief Retrieve a string from the material property table
*
* See the sample for aiGetMaterialFloat for more information.*/
// ---------------------------------------------------------------------------
aiGetMaterialString :: (pMat: *aiMaterial, pKey: *u8, type: u32, index: u32, pOut: *aiString) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/** Get the number of textures for a particular texture type.
*  @param[in] pMat Pointer to the input material. May not be NULL
*  @param type Texture type to check for
*  @return Number of textures for this type.
*  @note A texture can be easily queried using #aiGetMaterialTexture() */
// ---------------------------------------------------------------------------
aiGetMaterialTextureCount :: (pMat: *aiMaterial, type: aiTextureType) -> u32 #foreign assimp_vc143_mt;

aiGetMaterialTexture :: (mat: *aiMaterial, type: aiTextureType, index: u32, path: *aiString, mapping: *aiTextureMapping, uvindex: *u32, blend: *ai_real, op: *aiTextureOp, mapmode: *aiTextureMapMode, flags: *u32) -> aiReturn #foreign assimp_vc143_mt;

// ---------------------------------------------------------------------------
/**
*/
aiAnimInterpolation :: enum s32 {
    Step                           :: 0;

    Linear                         :: 1;

    Spherical_Linear               :: 2;

    Cubic_Spline                   :: 3;

    aiAnimInterpolation_Force32Bit :: 2147483647;

    aiAnimInterpolation_Step             :: Step;

    aiAnimInterpolation_Linear           :: Linear;

    aiAnimInterpolation_Spherical_Linear :: Spherical_Linear;

    aiAnimInterpolation_Cubic_Spline     :: Cubic_Spline;

    _aiAnimInterpolation_Force32Bit      :: aiAnimInterpolation_Force32Bit;
}

// ---------------------------------------------------------------------------
/** A time-value pair specifying a certain 3D vector for the given time. */
aiVectorKey :: struct {
    /** The time of this key */
    mTime:          float64;

    /** The value of this key */
    mValue:         aiVector3D;

    /** The interpolation setting of this key */
    mInterpolation: aiAnimInterpolation;
}

// ---------------------------------------------------------------------------
/** A time-value pair specifying a rotation for the given time.
*  Rotations are expressed with quaternions. */
aiQuatKey :: struct {
    /** The time of this key */
    mTime:          float64;

    /** The value of this key */
    mValue:         aiQuaternion;

    /** The interpolation setting of this key */
    mInterpolation: aiAnimInterpolation;
}

// ---------------------------------------------------------------------------
/** Binds a anim-mesh to a specific point in time. */
aiMeshKey :: struct {
    /** The time of this key */
    mTime:  float64;

    /** Index into the aiMesh::mAnimMeshes array of the
    *  mesh corresponding to the #aiMeshAnim hosting this
    *  key frame. The referenced anim mesh is evaluated
    *  according to the rules defined in the docs for #aiAnimMesh.*/
    mValue: u32;
}

// ---------------------------------------------------------------------------
/** Binds a morph anim mesh to a specific point in time. */
aiMeshMorphKey :: struct {
    /** The time of this key */
    mTime:                float64;

    /** The values and weights at the time of this key
    *   - mValues: index of attachment mesh to apply weight at the same position in mWeights
    *   - mWeights: weight to apply to the blend shape index at the same position in mValues
    */
    mValues:              *u32;
    mWeights:             *float64;

    /** The number of values and weights */
    mNumValuesAndWeights: u32;
}

// ---------------------------------------------------------------------------
/** Defines how an animation channel behaves outside the defined time
*  range. This corresponds to aiNodeAnim::mPreState and
*  aiNodeAnim::mPostState.*/
aiAnimBehaviour :: enum s32 {
    DEFAULT                    :: 0;

    CONSTANT                   :: 1;

    LINEAR                     :: 2;

    REPEAT                     :: 3;

    aiAnimBehaviour_Force32Bit :: 2147483647;

    aiAnimBehaviour_DEFAULT     :: DEFAULT;

    aiAnimBehaviour_CONSTANT    :: CONSTANT;

    aiAnimBehaviour_LINEAR      :: LINEAR;

    aiAnimBehaviour_REPEAT      :: REPEAT;

    _aiAnimBehaviour_Force32Bit :: aiAnimBehaviour_Force32Bit;
}

// ---------------------------------------------------------------------------
/** Describes the animation of a single node. The name specifies the
*  bone/node which is affected by this animation channel. The keyframes
*  are given in three separate series of values, one each for position,
*  rotation and scaling. The transformation matrix computed from these
*  values replaces the node's original transformation matrix at a
*  specific time.
*  This means all keys are absolute and not relative to the bone default pose.
*  The order in which the transformations are applied is
*  - as usual - scaling, rotation, translation.
*
*  @note All keys are returned in their correct, chronological order.
*  Duplicate keys don't pass the validation step. Most likely there
*  will be no negative time values, but they are not forbidden also ( so
*  implementations need to cope with them! ) */
aiNodeAnim :: struct {
    /** The name of the node affected by this animation. The node
    *  must exist and it must be unique.*/
    mNodeName:        aiString;

    /** The number of position keys */
    mNumPositionKeys: u32;

    /** The position keys of this animation channel. Positions are
    * specified as 3D vector. The array is mNumPositionKeys in size.
    *
    * If there are position keys, there will also be at least one
    * scaling and one rotation key.*/
    mPositionKeys:    *aiVectorKey;

    /** The number of rotation keys */
    mNumRotationKeys: u32;

    /** The rotation keys of this animation channel. Rotations are
    *  given as quaternions,  which are 4D vectors. The array is
    *  mNumRotationKeys in size.
    *
    * If there are rotation keys, there will also be at least one
    * scaling and one position key. */
    mRotationKeys:    *aiQuatKey;

    /** The number of scaling keys */
    mNumScalingKeys:  u32;

    /** The scaling keys of this animation channel. Scalings are
    *  specified as 3D vector. The array is mNumScalingKeys in size.
    *
    * If there are scaling keys, there will also be at least one
    * position and one rotation key.*/
    mScalingKeys:     *aiVectorKey;

    /** Defines how the animation behaves before the first
    *  key is encountered.
    *
    *  The default value is aiAnimBehaviour_DEFAULT (the original
    *  transformation matrix of the affected node is used).*/
    mPreState:        aiAnimBehaviour;

    /** Defines how the animation behaves after the last
    *  key was processed.
    *
    *  The default value is aiAnimBehaviour_DEFAULT (the original
    *  transformation matrix of the affected node is taken).*/
    mPostState:       aiAnimBehaviour;
}

// ---------------------------------------------------------------------------
/** Describes vertex-based animations for a single mesh or a group of
*  meshes. Meshes carry the animation data for each frame in their
*  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to
*  define keyframes linking each mesh attachment to a particular
*  point in time. */
aiMeshAnim :: struct {
    /** Name of the mesh to be animated. An empty string is not allowed,
    *  animated meshes need to be named (not necessarily uniquely,
    *  the name can basically serve as wild-card to select a group
    *  of meshes with similar animation setup)*/
    mName:    aiString;

    /** Size of the #mKeys array. Must be 1, at least. */
    mNumKeys: u32;

    /** Key frames of the animation. May not be nullptr. */
    mKeys:    *aiMeshKey;
}

// ---------------------------------------------------------------------------
/** Describes a morphing animation of a given mesh. */
aiMeshMorphAnim :: struct {
    /** Name of the mesh to be animated. An empty string is not allowed,
    *  animated meshes need to be named (not necessarily uniquely,
    *  the name can basically serve as wildcard to select a group
    *  of meshes with similar animation setup)*/
    mName:    aiString;

    /** Size of the #mKeys array. Must be 1, at least. */
    mNumKeys: u32;

    /** Key frames of the animation. May not be nullptr. */
    mKeys:    *aiMeshMorphKey;
}

// ---------------------------------------------------------------------------
/** An animation consists of key-frame data for a number of nodes. For
*  each node affected by the animation a separate series of data is given.*/
aiAnimation :: struct {
    /** The name of the animation. If the modeling package this data was
    *  exported from does support only a single animation channel, this
    *  name is usually empty (length is zero). */
    mName:                 aiString;

    /** Duration of the animation in ticks.  */
    mDuration:             float64;

    /** Ticks per second. 0 if not specified in the imported file */
    mTicksPerSecond:       float64;

    /** The number of bone animation channels. Each channel affects
    *  a single node. */
    mNumChannels:          u32;

    /** The node animation channels. Each channel affects a single node.
    *  The array is mNumChannels in size. */
    mChannels:             **aiNodeAnim;

    /** The number of mesh animation channels. Each channel affects
    *  a single mesh and defines vertex-based animation. */
    mNumMeshChannels:      u32;

    /** The mesh animation channels. Each channel affects a single mesh.
    *  The array is mNumMeshChannels in size. */
    mMeshChannels:         **aiMeshAnim;

    /** The number of mesh animation channels. Each channel affects
    *  a single mesh and defines morphing animation. */
    mNumMorphMeshChannels: u32;

    /** The morph mesh animation channels. Each channel affects a single mesh.
    *  The array is mNumMorphMeshChannels in size. */
    mMorphMeshChannels:    **aiMeshMorphAnim;
}

// -------------------------------------------------------------------------------
/**
* Enum used to distinguish data types
*/
// -------------------------------------------------------------------------------
aiMetadataType :: enum s32 {
    AI_BOOL       :: 0;
    AI_INT32      :: 1;
    AI_UINT64     :: 2;
    AI_FLOAT      :: 3;
    AI_DOUBLE     :: 4;
    AI_AISTRING   :: 5;
    AI_AIVECTOR3D :: 6;
    AI_AIMETADATA :: 7;
    AI_INT64      :: 8;
    AI_UINT32     :: 9;
    AI_META_MAX   :: 10;

    FORCE_32BIT   :: 2147483647;
}

// -------------------------------------------------------------------------------
/**
* Metadata entry
*
* The type field uniquely identifies the underlying type of the data field
*/
// -------------------------------------------------------------------------------
aiMetadataEntry :: struct {
    mType: aiMetadataType;
    mData: *void;
}

// -------------------------------------------------------------------------------
/**
* Container for holding metadata.
*
* Metadata is a key-value store using string keys and values.
*/
// -------------------------------------------------------------------------------
aiMetadata :: struct {
    /** Length of the mKeys and mValues arrays, respectively */
    mNumProperties: u32;

    /** Arrays of keys, may not be NULL. Entries in this array may not be NULL as well. */
    mKeys:          *aiString;

    /** Arrays of values, may not be NULL. Entries in this array may be NULL if the
    * corresponding property key has no assigned value. */
    mValues:        *aiMetadataEntry;
}

/** Mixed set of flags for #aiImporterDesc, indicating some features
*  common to many importers*/
aiImporterFlags :: enum s32 {
    SupportTextFlavour       :: 1;

    SupportBinaryFlavour     :: 2;

    SupportCompressedFlavour :: 4;

    LimitedSupport           :: 8;

    Experimental             :: 16;

    aiImporterFlags_SupportTextFlavour       :: SupportTextFlavour;

    aiImporterFlags_SupportBinaryFlavour     :: SupportBinaryFlavour;

    aiImporterFlags_SupportCompressedFlavour :: SupportCompressedFlavour;

    aiImporterFlags_LimitedSupport           :: LimitedSupport;

    aiImporterFlags_Experimental             :: Experimental;
}

/** Meta information about a particular importer. Importers need to fill
*  this structure, but they can freely decide how talkative they are.
*  A common use case for loader meta info is a user interface
*  in which the user can choose between various import/export file
*  formats. Building such an UI by hand means a lot of maintenance
*  as importers/exporters are added to Assimp, so it might be useful
*  to have a common mechanism to query some rough importer
*  characteristics. */
aiImporterDesc :: struct {
    /** Full name of the importer (i.e. Blender3D importer)*/
    mName:           *u8;

    /** Original author (left blank if unknown or whole assimp team) */
    mAuthor:         *u8;

    /** Current maintainer, left blank if the author maintains */
    mMaintainer:     *u8;

    /** Implementation comments, i.e. unimplemented features*/
    mComments:       *u8;

    /** These flags indicate some characteristics common to many
    importers. */
    mFlags:          u32;

    /** Minimum format version that can be loaded im major.minor format,
    both are set to 0 if there is either no version scheme
    or if the loader doesn't care. */
    mMinMajor:       u32;
    mMinMinor:       u32;

    /** Maximum format version that can be loaded im major.minor format,
    both are set to 0 if there is either no version scheme
    or if the loader doesn't care. Loaders that expect to be
    forward-compatible to potential future format versions should
    indicate  zero, otherwise they should specify the current
    maximum version.*/
    mMaxMajor:       u32;
    mMaxMinor:       u32;

    /** List of file extensions this importer can handle.
    List entries are separated by space characters.
    All entries are lower case without a leading dot (i.e.
    "xml dae" would be a valid value. Note that multiple
    importers may respond to the same file extension -
    assimp calls all importers in the order in which they
    are registered and each importer gets the opportunity
    to load the file until one importer "claims" the file. Apart
    from file extension checks, importers typically use
    other methods to quickly reject files (i.e. magic
    words) so this does not mean that common or generic
    file extensions such as XML would be tediously slow. */
    mFileExtensions: *u8;
}

/** \brief  Returns the Importer description for a given extension.

Will return a nullptr if no assigned importer desc. was found for the given extension
\param  extension   [in] The extension to look for
\return A pointer showing to the ImporterDesc, \see aiImporterDesc.
*/
aiGetImporterDesc :: (extension: *u8) -> *aiImporterDesc #foreign assimp_vc143_mt;

aiFileIO :: struct {}

aiLogStreamCallback :: #type (unknown0: *u8, unknown1: *u8) -> void #c_call;

// --------------------------------------------------------------------------------
/** C-API: Represents a log stream. A log stream receives all log messages and
*  streams them _somewhere_.
*  @see aiGetPredefinedLogStream
*  @see aiAttachLogStream
*  @see aiDetachLogStream */
// --------------------------------------------------------------------------------
aiLogStream :: struct {
    /** callback to be called */
    callback: aiLogStreamCallback;

    /** user data to be passed to the callback */
    user:     *u8;
}

// --------------------------------------------------------------------------------
/** C-API: Represents an opaque set of settings to be used during importing.
*  @see aiCreatePropertyStore
*  @see aiReleasePropertyStore
*  @see aiImportFileExWithProperties
*  @see aiSetPropertyInteger
*  @see aiSetPropertyFloat
*  @see aiSetPropertyString
*  @see aiSetPropertyMatrix
*/
// --------------------------------------------------------------------------------
aiPropertyStore :: struct {
    sentinel: u8;
}

/** Our own C boolean type */
aiBool :: s32;

// --------------------------------------------------------------------------------
/** Reads the given file and returns its content.
*
* If the call succeeds, the imported data is returned in an aiScene structure.
* The data is intended to be read-only, it stays property of the ASSIMP
* library and will be stable until aiReleaseImport() is called. After you're
* done with it, call aiReleaseImport() to free the resources associated with
* this file. If the import fails, NULL is returned instead. Call
* aiGetErrorString() to retrieve a human-readable error text.
* @param pFile Path and filename of the file to be imported,
*   expected to be a null-terminated c-string. NULL is not a valid value.
* @param pFlags Optional post processing steps to be executed after
*   a successful import. Provide a bitwise combination of the
*   #aiPostProcessSteps flags.
* @return Pointer to the imported data or NULL if the import failed.
*/
aiImportFile :: (pFile: *u8, pFlags: u32) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Reads the given file using user-defined I/O functions and returns
*   its content.
*
* If the call succeeds, the imported data is returned in an aiScene structure.
* The data is intended to be read-only, it stays property of the ASSIMP
* library and will be stable until aiReleaseImport() is called. After you're
* done with it, call aiReleaseImport() to free the resources associated with
* this file. If the import fails, NULL is returned instead. Call
* aiGetErrorString() to retrieve a human-readable error text.
* @param pFile Path and filename of the file to be imported,
*   expected to be a null-terminated c-string. NULL is not a valid value.
* @param pFlags Optional post processing steps to be executed after
*   a successful import. Provide a bitwise combination of the
*   #aiPostProcessSteps flags.
* @param pFS aiFileIO structure. Will be used to open the model file itself
*   and any other files the loader needs to open.  Pass NULL to use the default
*   implementation.
* @return Pointer to the imported data or NULL if the import failed.
* @note Include <aiFileIO.h> for the definition of #aiFileIO.
*/
aiImportFileEx :: (pFile: *u8, pFlags: u32, pFS: *aiFileIO) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
*
* @param pFile Path and filename of the file to be imported,
*   expected to be a null-terminated c-string. NULL is not a valid value.
* @param pFlags Optional post processing steps to be executed after
*   a successful import. Provide a bitwise combination of the
*   #aiPostProcessSteps flags.
* @param pFS aiFileIO structure. Will be used to open the model file itself
*   and any other files the loader needs to open.  Pass NULL to use the default
*   implementation.
* @param pProps #aiPropertyStore instance containing import settings.
* @return Pointer to the imported data or NULL if the import failed.
* @note Include <aiFileIO.h> for the definition of #aiFileIO.
* @see aiImportFileEx
*/
aiImportFileExWithProperties :: (pFile: *u8, pFlags: u32, pFS: *aiFileIO, pProps: *aiPropertyStore) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Reads the given file from a given memory buffer,
*
* If the call succeeds, the contents of the file are returned as a pointer to an
* aiScene object. The returned data is intended to be read-only, the importer keeps
* ownership of the data and will destroy it upon destruction. If the import fails,
* NULL is returned.
* A human-readable error description can be retrieved by calling aiGetErrorString().
* @param pBuffer Pointer to the file data
* @param pLength Length of pBuffer, in bytes
* @param pFlags Optional post processing steps to be executed after
*   a successful import. Provide a bitwise combination of the
*   #aiPostProcessSteps flags. If you wish to inspect the imported
*   scene first in order to fine-tune your post-processing setup,
*   consider to use #aiApplyPostProcessing().
* @param pHint An additional hint to the library. If this is a non empty string,
*   the library looks for a loader to support the file extension specified by pHint
*   and passes the file to the first matching loader. If this loader is unable to
*   completely the request, the library continues and tries to determine the file
*   format on its own, a task that may or may not be successful.
*   Check the return value, and you'll know ...
* @return A pointer to the imported data, NULL if the import failed.
*
* @note This is a straightforward way to decode models from memory
* buffers, but it doesn't handle model formats that spread their
* data across multiple files or even directories. Examples include
* OBJ or MD3, which outsource parts of their material info into
* external scripts. If you need full functionality, provide
* a custom IOSystem to make Assimp find these files and use
* the regular aiImportFileEx()/aiImportFileExWithProperties() API.
*/
aiImportFileFromMemory :: (pBuffer: *u8, pLength: u32, pFlags: u32, pHint: *u8) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
*
* @param pBuffer Pointer to the file data
* @param pLength Length of pBuffer, in bytes
* @param pFlags Optional post processing steps to be executed after
*   a successful import. Provide a bitwise combination of the
*   #aiPostProcessSteps flags. If you wish to inspect the imported
*   scene first in order to fine-tune your post-processing setup,
*   consider to use #aiApplyPostProcessing().
* @param pHint An additional hint to the library. If this is a non empty string,
*   the library looks for a loader to support the file extension specified by pHint
*   and passes the file to the first matching loader. If this loader is unable to
*   completely the request, the library continues and tries to determine the file
*   format on its own, a task that may or may not be successful.
*   Check the return value, and you'll know ...
* @param pProps #aiPropertyStore instance containing import settings.
* @return A pointer to the imported data, NULL if the import failed.
*
* @note This is a straightforward way to decode models from memory
* buffers, but it doesn't handle model formats that spread their
* data across multiple files or even directories. Examples include
* OBJ or MD3, which outsource parts of their material info into
* external scripts. If you need full functionality, provide
* a custom IOSystem to make Assimp find these files and use
* the regular aiImportFileEx()/aiImportFileExWithProperties() API.
* @see aiImportFileFromMemory
*/
aiImportFileFromMemoryWithProperties :: (pBuffer: *u8, pLength: u32, pFlags: u32, pHint: *u8, pProps: *aiPropertyStore) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Apply post-processing to an already-imported scene.
*
* This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
* same flags. However, you can use this separate function to inspect the imported
* scene first to fine-tune your post-processing setup.
* @param pScene Scene to work on.
* @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
* @return A pointer to the post-processed data. Post processing is done in-place,
*   meaning this is still the same #aiScene which you passed for pScene. However,
*   _if_ post-processing failed, the scene could now be NULL. That's quite a rare
*   case, post processing steps are not really designed to 'fail'. To be exact,
*   the #aiProcess_ValidateDataStructure flag is currently the only post processing step
*   which can actually cause the scene to be reset to NULL.
*/
aiApplyPostProcessing :: (pScene: *aiScene, pFlags: u32) -> *aiScene #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get one of the predefine log streams. This is the quick'n'easy solution to
*  access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
*  overall import performance.
*
*  Usage is rather simple (this will stream the log to a file, named log.txt, and
*  the stdout stream of the process:
*  @code
*    struct aiLogStream c;
*    c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
*    aiAttachLogStream(&c);
*    c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
*    aiAttachLogStream(&c);
*  @endcode
*
*  @param pStreams One of the #aiDefaultLogStream enumerated values.
*  @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
*    Pass NULL for all other flags.
*  @return The log stream. callback is set to NULL if something went wrong.
*/
aiGetPredefinedLogStream :: (pStreams: aiDefaultLogStream, file: *u8) -> aiLogStream #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Attach a custom log stream to the libraries' logging system.
*
*  Attaching a log stream can slightly reduce Assimp's overall import
*  performance. Multiple log-streams can be attached.
*  @param stream Describes the new log stream.
*  @note To ensure proper destruction of the logging system, you need to manually
*    call aiDetachLogStream() on every single log stream you attach.
*    Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
*/
aiAttachLogStream :: (stream: *aiLogStream) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Enable verbose logging. Verbose logging includes debug-related stuff and
*  detailed import statistics. This can have severe impact on import performance
*  and memory consumption. However, it might be useful to find out why a file
*  didn't read correctly.
*  @param d AI_TRUE or AI_FALSE, your decision.
*/
aiEnableVerboseLogging :: (d: aiBool) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Detach a custom log stream from the libraries' logging system.
*
*  This is the counterpart of #aiAttachLogStream. If you attached a stream,
*  don't forget to detach it again.
*  @param stream The log stream to be detached.
*  @return AI_SUCCESS if the log stream has been detached successfully.
*  @see aiDetachAllLogStreams
*/
aiDetachLogStream :: (stream: *aiLogStream) -> aiReturn #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Detach all active log streams from the libraries' logging system.
*  This ensures that the logging system is terminated properly and all
*  resources allocated by it are actually freed. If you attached a stream,
*  don't forget to detach it again.
*  @see aiAttachLogStream
*  @see aiDetachLogStream
*/
aiDetachAllLogStreams :: () -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Releases all resources associated with the given import process.
*
* Call this function after you're done with the imported data.
* @param pScene The imported data to release. NULL is a valid value.
*/
aiReleaseImport :: (pScene: *aiScene) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns the error text of the last failed import process.
*
* @return A textual description of the error that occurred at the last
* import process. NULL if there was no error. There can't be an error if you
* got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
*/
aiGetErrorString :: () -> *u8 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns whether a given file extension is supported by ASSIMP
*
* @param szExtension Extension for which the function queries support for.
* Must include a leading dot '.'. Example: ".3ds", ".md3"
* @return AI_TRUE if the file extension is supported.
*/
aiIsExtensionSupported :: (szExtension: *u8) -> aiBool #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a list of all file extensions supported by ASSIMP.
*
* If a file extension is contained in the list this does, of course, not
* mean that ASSIMP is able to load all files with this extension.
* @param szOut String to receive the extension list.
* Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
*/
aiGetExtensionList :: (szOut: *aiString) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the approximated storage required by an imported asset
* @param pIn Input asset.
* @param in Data structure to be filled.
*/
aiGetMemoryRequirements :: (pIn: *aiScene, in: *aiMemoryInfo) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns an embedded texture, or nullptr.
* @param pIn Input asset.
* @param filename Texture path extracted from aiGetMaterialString.
*/
aiGetEmbeddedTexture :: (pIn: *aiScene, filename: *u8) -> *aiTexture #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create an empty property store. Property stores are used to collect import
*  settings.
* @return New property store. Property stores need to be manually destroyed using
*   the #aiReleasePropertyStore API function.
*/
aiCreatePropertyStore :: () -> *aiPropertyStore #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Delete a property store.
* @param p Property store to be deleted.
*/
aiReleasePropertyStore :: (p: *aiPropertyStore) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Set an integer property.
*
*  This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
*  interface, properties are always shared by all imports. It is not possible to
*  specify them per import.
*
* @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
* @param szName Name of the configuration property to be set. All supported
*   public properties are defined in the config.h header file (AI_CONFIG_XXX).
* @param value New value for the property
*/
aiSetImportPropertyInteger :: (store: *aiPropertyStore, szName: *u8, value: s32) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Set a floating-point property.
*
*  This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
*  interface, properties are always shared by all imports. It is not possible to
*  specify them per import.
*
* @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
* @param szName Name of the configuration property to be set. All supported
*   public properties are defined in the config.h header file (AI_CONFIG_XXX).
* @param value New value for the property
*/
aiSetImportPropertyFloat :: (store: *aiPropertyStore, szName: *u8, value: ai_real) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Set a string property.
*
*  This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
*  interface, properties are always shared by all imports. It is not possible to
*  specify them per import.
*
* @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
* @param szName Name of the configuration property to be set. All supported
*   public properties are defined in the config.h header file (AI_CONFIG_XXX).
* @param st New value for the property
*/
aiSetImportPropertyString :: (store: *aiPropertyStore, szName: *u8, st: *aiString) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Set a matrix property.
*
*  This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
*  interface, properties are always shared by all imports. It is not possible to
*  specify them per import.
*
* @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
* @param szName Name of the configuration property to be set. All supported
*   public properties are defined in the config.h header file (AI_CONFIG_XXX).
* @param mat New value for the property
*/
aiSetImportPropertyMatrix :: (store: *aiPropertyStore, szName: *u8, mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Construct a quaternion from a 3x3 rotation matrix.
*  @param quat Receives the output quaternion.
*  @param mat Matrix to 'quaternionize'.
*  @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
*/
aiCreateQuaternionFromMatrix :: (quat: *aiQuaternion, mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its rotational, translational and
*  scaling components.
*
* @param mat Matrix to decompose
* @param scaling Receives the scaling component
* @param rotation Receives the rotational component
* @param position Receives the translational component.
* @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
*/
aiDecomposeMatrix :: (mat: *aiMatrix4x4, scaling: *aiVector3D, rotation: *aiQuaternion, position: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Transpose a 4x4 matrix.
*  @param mat Pointer to the matrix to be transposed
*/
aiTransposeMatrix4 :: (mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Transpose a 3x3 matrix.
*  @param mat Pointer to the matrix to be transposed
*/
aiTransposeMatrix3 :: (mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Transform a vector by a 3x3 matrix
*  @param vec Vector to be transformed.
*  @param mat Matrix to transform the vector with.
*/
aiTransformVecByMatrix3 :: (vec: *aiVector3D, mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Transform a vector by a 4x4 matrix
*  @param vec Vector to be transformed.
*  @param mat Matrix to transform the vector with.
*/
aiTransformVecByMatrix4 :: (vec: *aiVector3D, mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply two 4x4 matrices.
*  @param dst First factor, receives result.
*  @param src Matrix to be multiplied with 'dst'.
*/
aiMultiplyMatrix4 :: (dst: *aiMatrix4x4, src: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply two 3x3 matrices.
*  @param dst First factor, receives result.
*  @param src Matrix to be multiplied with 'dst'.
*/
aiMultiplyMatrix3 :: (dst: *aiMatrix3x3, src: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 3x3 identity matrix.
*  @param mat Matrix to receive its personal identity
*/
aiIdentityMatrix3 :: (mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 identity matrix.
*  @param mat Matrix to receive its personal identity
*/
aiIdentityMatrix4 :: (mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns the number of import file formats available in the current Assimp build.
* Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
*/
aiGetImportFormatCount :: () -> u64 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns a description of the nth import file format. Use #aiGetImportFormatCount()
* to learn how many import formats are supported.
* @param pIndex Index of the import format to retrieve information for. Valid range is
*    0 to #aiGetImportFormatCount()
* @return A description of that specific import format. NULL if pIndex is out of range.
*/
aiGetImportFormatDescription :: (pIndex: u64) -> *aiImporterDesc #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 2D vectors are equal.
*  @param a First vector to compare
*  @param b Second vector to compare
*  @return 1 if the vectors are equal
*  @return 0 if the vectors are not equal
*/
aiVector2AreEqual :: (a: *aiVector2D, b: *aiVector2D) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 2D vectors are equal using epsilon.
*  @param a First vector to compare
*  @param b Second vector to compare
*  @param epsilon Epsilon
*  @return 1 if the vectors are equal
*  @return 0 if the vectors are not equal
*/
aiVector2AreEqualEpsilon :: (a: *aiVector2D, b: *aiVector2D, epsilon: float) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Add 2D vectors.
*  @param dst First addend, receives result.
*  @param src Vector to be added to 'dst'.
*/
aiVector2Add :: (dst: *aiVector2D, src: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Subtract 2D vectors.
*  @param dst Minuend, receives result.
*  @param src Vector to be subtracted from 'dst'.
*/
aiVector2Subtract :: (dst: *aiVector2D, src: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply a 2D vector by a scalar.
*  @param dst Vector to be scaled by \p s
*  @param s Scale factor
*/
aiVector2Scale :: (dst: *aiVector2D, s: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply each component of a 2D vector with
*  the components of another vector.
*  @param dst First vector, receives result
*  @param other Second vector
*/
aiVector2SymMul :: (dst: *aiVector2D, other: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Divide a 2D vector by a scalar.
*  @param dst Vector to be divided by \p s
*  @param s Scalar divisor
*/
aiVector2DivideByScalar :: (dst: *aiVector2D, s: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Divide each component of a 2D vector by
*  the components of another vector.
*  @param dst Vector as the dividend
*  @param v Vector as the divisor
*/
aiVector2DivideByVector :: (dst: *aiVector2D, v: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the length of a 2D vector.
*  @return v Vector to evaluate
*/
aiVector2Length :: (v: *aiVector2D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the squared length of a 2D vector.
*  @return v Vector to evaluate
*/
aiVector2SquareLength :: (v: *aiVector2D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Negate a 2D vector.
*  @param dst Vector to be negated
*/
aiVector2Negate :: (dst: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the dot product of 2D vectors.
*  @param a First vector
*  @param b Second vector
*  @return The dot product of vectors
*/
aiVector2DotProduct :: (a: *aiVector2D, b: *aiVector2D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Normalize a 2D vector.
*  @param v Vector to normalize
*/
aiVector2Normalize :: (v: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 3D vectors are equal.
*  @param a First vector to compare
*  @param b Second vector to compare
*  @return 1 if the vectors are equal
*  @return 0 if the vectors are not equal
*/
aiVector3AreEqual :: (a: *aiVector3D, b: *aiVector3D) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 3D vectors are equal using epsilon.
*  @param a First vector to compare
*  @param b Second vector to compare
*  @param epsilon Epsilon
*  @return 1 if the vectors are equal
*  @return 0 if the vectors are not equal
*/
aiVector3AreEqualEpsilon :: (a: *aiVector3D, b: *aiVector3D, epsilon: float) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if vector \p a is less than vector \p b.
*  @param a First vector to compare
*  @param b Second vector to compare
*  @param epsilon Epsilon
*  @return 1 if \p a is less than \p b
*  @return 0 if \p a is equal or greater than \p b
*/
aiVector3LessThan :: (a: *aiVector3D, b: *aiVector3D) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Add 3D vectors.
*  @param dst First addend, receives result.
*  @param src Vector to be added to 'dst'.
*/
aiVector3Add :: (dst: *aiVector3D, src: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Subtract 3D vectors.
*  @param dst Minuend, receives result.
*  @param src Vector to be subtracted from 'dst'.
*/
aiVector3Subtract :: (dst: *aiVector3D, src: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply a 3D vector by a scalar.
*  @param dst Vector to be scaled by \p s
*  @param s Scale factor
*/
aiVector3Scale :: (dst: *aiVector3D, s: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply each component of a 3D vector with
*  the components of another vector.
*  @param dst First vector, receives result
*  @param other Second vector
*/
aiVector3SymMul :: (dst: *aiVector3D, other: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Divide a 3D vector by a scalar.
*  @param dst Vector to be divided by \p s
*  @param s Scalar divisor
*/
aiVector3DivideByScalar :: (dst: *aiVector3D, s: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Divide each component of a 3D vector by
*  the components of another vector.
*  @param dst Vector as the dividend
*  @param v Vector as the divisor
*/
aiVector3DivideByVector :: (dst: *aiVector3D, v: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the length of a 3D vector.
*  @return v Vector to evaluate
*/
aiVector3Length :: (v: *aiVector3D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the squared length of a 3D vector.
*  @return v Vector to evaluate
*/
aiVector3SquareLength :: (v: *aiVector3D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Negate a 3D vector.
*  @param dst Vector to be negated
*/
aiVector3Negate :: (dst: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the dot product of 3D vectors.
*  @param a First vector
*  @param b Second vector
*  @return The dot product of vectors
*/
aiVector3DotProduct :: (a: *aiVector3D, b: *aiVector3D) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get cross product of 3D vectors.
*  @param dst Vector to receive the result.
*  @param a First vector
*  @param b Second vector
*  @return The dot product of vectors
*/
aiVector3CrossProduct :: (dst: *aiVector3D, a: *aiVector3D, b: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Normalize a 3D vector.
*  @param v Vector to normalize
*/
aiVector3Normalize :: (v: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check for division by zero and normalize a 3D vector.
*  @param v Vector to normalize
*/
aiVector3NormalizeSafe :: (v: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Rotate a 3D vector by a quaternion.
*  @param v The vector to rotate by \p q
*  @param q Quaternion to use to rotate \p v
*/
aiVector3RotateByQuaternion :: (v: *aiVector3D, q: *aiQuaternion) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Construct a 3x3 matrix from a 4x4 matrix.
*  @param dst Receives the output matrix
*  @param mat The 4x4 matrix to use
*/
aiMatrix3FromMatrix4 :: (dst: *aiMatrix3x3, mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Construct a 3x3 matrix from a quaternion.
*  @param mat Receives the output matrix
*  @param q The quaternion matrix to use
*/
aiMatrix3FromQuaternion :: (mat: *aiMatrix3x3, q: *aiQuaternion) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 3x3 matrices are equal.
*  @param a First matrix to compare
*  @param b Second matrix to compare
*  @return 1 if the matrices are equal
*  @return 0 if the matrices are not equal
*/
aiMatrix3AreEqual :: (a: *aiMatrix3x3, b: *aiMatrix3x3) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 3x3 matrices are equal.
*  @param a First matrix to compare
*  @param b Second matrix to compare
*  @param epsilon Epsilon
*  @return 1 if the matrices are equal
*  @return 0 if the matrices are not equal
*/
aiMatrix3AreEqualEpsilon :: (a: *aiMatrix3x3, b: *aiMatrix3x3, epsilon: float) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Invert a 3x3 matrix.
*  @param mat Matrix to invert
*/
aiMatrix3Inverse :: (mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the determinant of a 3x3 matrix.
*  @param mat Matrix to get the determinant from
*/
aiMatrix3Determinant :: (mat: *aiMatrix3x3) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 3x3 rotation matrix around the Z axis.
*  @param mat Receives the output matrix
*  @param angle Rotation angle, in radians
*/
aiMatrix3RotationZ :: (mat: *aiMatrix3x3, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
*  @param mat Receives the output matrix
*  @param axis Rotation axis, should be a normalized vector
*  @param angle Rotation angle, in radians
*/
aiMatrix3FromRotationAroundAxis :: (mat: *aiMatrix3x3, axis: *aiVector3D, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 3x3 translation matrix.
*  @param mat Receives the output matrix
*  @param translation The translation vector
*/
aiMatrix3Translation :: (mat: *aiMatrix3x3, translation: *aiVector2D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create a 3x3 matrix that rotates one vector to another vector.
*  @param mat Receives the output matrix
*  @param from Vector to rotate from
*  @param to Vector to rotate to
*/
aiMatrix3FromTo :: (mat: *aiMatrix3x3, from: *aiVector3D, to: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Construct a 4x4 matrix from a 3x3 matrix.
*  @param dst Receives the output matrix
*  @param mat The 3x3 matrix to use
*/
aiMatrix4FromMatrix3 :: (dst: *aiMatrix4x4, mat: *aiMatrix3x3) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Construct a 4x4 matrix from scaling, rotation and position.
*  @param mat Receives the output matrix.
*  @param scaling The scaling for the x,y,z axes
*  @param rotation The rotation as a hamilton quaternion
*  @param position The position for the x,y,z axes
*/
aiMatrix4FromScalingQuaternionPosition :: (mat: *aiMatrix4x4, scaling: *aiVector3D, rotation: *aiQuaternion, position: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Add 4x4 matrices.
*  @param dst First addend, receives result.
*  @param src Matrix to be added to 'dst'.
*/
aiMatrix4Add :: (dst: *aiMatrix4x4, src: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 4x4 matrices are equal.
*  @param a First matrix to compare
*  @param b Second matrix to compare
*  @return 1 if the matrices are equal
*  @return 0 if the matrices are not equal
*/
aiMatrix4AreEqual :: (a: *aiMatrix4x4, b: *aiMatrix4x4) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if 4x4 matrices are equal.
*  @param a First matrix to compare
*  @param b Second matrix to compare
*  @param epsilon Epsilon
*  @return 1 if the matrices are equal
*  @return 0 if the matrices are not equal
*/
aiMatrix4AreEqualEpsilon :: (a: *aiMatrix4x4, b: *aiMatrix4x4, epsilon: float) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Invert a 4x4 matrix.
*  @param result Matrix to invert
*/
aiMatrix4Inverse :: (mat: *aiMatrix4x4) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get the determinant of a 4x4 matrix.
*  @param mat Matrix to get the determinant from
*  @return The determinant of the matrix
*/
aiMatrix4Determinant :: (mat: *aiMatrix4x4) -> ai_real #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns true of the matrix is the identity matrix.
*  @param mat Matrix to get the determinant from
*  @return 1 if \p mat is an identity matrix.
*  @return 0 if \p mat is not an identity matrix.
*/
aiMatrix4IsIdentity :: (mat: *aiMatrix4x4) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its scaling,
*  rotational as euler angles, and translational components.
*
* @param mat Matrix to decompose
* @param scaling Receives the output scaling for the x,y,z axes
* @param rotation Receives the output rotation as a Euler angles
* @param position Receives the output position for the x,y,z axes
*/
aiMatrix4DecomposeIntoScalingEulerAnglesPosition :: (mat: *aiMatrix4x4, scaling: *aiVector3D, rotation: *aiVector3D, position: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its scaling,
*  rotational split into an axis and rotational angle,
*  and it's translational components.
*
* @param mat Matrix to decompose
* @param rotation Receives the rotational component
* @param axis Receives the output rotation axis
* @param angle Receives the output rotation angle
* @param position Receives the output position for the x,y,z axes.
*/
aiMatrix4DecomposeIntoScalingAxisAnglePosition :: (mat: *aiMatrix4x4, scaling: *aiVector3D, axis: *aiVector3D, angle: *ai_real, position: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its rotational and
*  translational components.
*
* @param mat Matrix to decompose
* @param rotation Receives the rotational component
* @param position Receives the translational component.
*/
aiMatrix4DecomposeNoScaling :: (mat: *aiMatrix4x4, rotation: *aiQuaternion, position: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Creates a 4x4 matrix from a set of euler angles.
*  @param mat Receives the output matrix
*  @param x Rotation angle for the x-axis, in radians
*  @param y Rotation angle for the y-axis, in radians
*  @param z Rotation angle for the z-axis, in radians
*/
aiMatrix4FromEulerAngles :: (mat: *aiMatrix4x4, x: float, y: float, z: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the X axis.
*  @param mat Receives the output matrix
*  @param angle Rotation angle, in radians
*/
aiMatrix4RotationX :: (mat: *aiMatrix4x4, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the Y axis.
*  @param mat Receives the output matrix
*  @param angle Rotation angle, in radians
*/
aiMatrix4RotationY :: (mat: *aiMatrix4x4, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the Z axis.
*  @param mat Receives the output matrix
*  @param angle Rotation angle, in radians
*/
aiMatrix4RotationZ :: (mat: *aiMatrix4x4, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.
*  @param mat Receives the output matrix
*  @param axis Rotation axis, should be a normalized vector
*  @param angle Rotation angle, in radians
*/
aiMatrix4FromRotationAroundAxis :: (mat: *aiMatrix4x4, axis: *aiVector3D, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 translation matrix.
*  @param mat Receives the output matrix
*  @param translation The translation vector
*/
aiMatrix4Translation :: (mat: *aiMatrix4x4, translation: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Get a 4x4 scaling matrix.
*  @param mat Receives the output matrix
*  @param scaling The scaling vector
*/
aiMatrix4Scaling :: (mat: *aiMatrix4x4, scaling: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create a 4x4 matrix that rotates one vector to another vector.
*  @param mat Receives the output matrix
*  @param from Vector to rotate from
*  @param to Vector to rotate to
*/
aiMatrix4FromTo :: (mat: *aiMatrix4x4, from: *aiVector3D, to: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create a Quaternion from euler angles.
*  @param q Receives the output quaternion
*  @param x Rotation angle for the x-axis, in radians
*  @param y Rotation angle for the y-axis, in radians
*  @param z Rotation angle for the z-axis, in radians
*/
aiQuaternionFromEulerAngles :: (q: *aiQuaternion, x: float, y: float, z: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create a Quaternion from an axis angle pair.
*  @param q Receives the output quaternion
*  @param axis The orientation axis
*  @param angle The rotation angle, in radians
*/
aiQuaternionFromAxisAngle :: (q: *aiQuaternion, axis: *aiVector3D, angle: float) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Create a Quaternion from a normalized quaternion stored
*  in a 3D vector.
*  @param q Receives the output quaternion
*  @param normalized The vector that stores the quaternion
*/
aiQuaternionFromNormalizedQuaternion :: (q: *aiQuaternion, normalized: *aiVector3D) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if quaternions are equal.
*  @param a First quaternion to compare
*  @param b Second quaternion to compare
*  @return 1 if the quaternions are equal
*  @return 0 if the quaternions are not equal
*/
aiQuaternionAreEqual :: (a: *aiQuaternion, b: *aiQuaternion) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Check if quaternions are equal using epsilon.
*  @param a First quaternion to compare
*  @param b Second quaternion to compare
*  @param epsilon Epsilon
*  @return 1 if the quaternions are equal
*  @return 0 if the quaternions are not equal
*/
aiQuaternionAreEqualEpsilon :: (a: *aiQuaternion, b: *aiQuaternion, epsilon: float) -> s32 #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Normalize a quaternion.
*  @param q Quaternion to normalize
*/
aiQuaternionNormalize :: (q: *aiQuaternion) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Compute quaternion conjugate.
*  @param q Quaternion to compute conjugate,
*           receives the output quaternion
*/
aiQuaternionConjugate :: (q: *aiQuaternion) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Multiply quaternions.
*  @param dst First quaternion, receives the output quaternion
*  @param q Second quaternion
*/
aiQuaternionMultiply :: (dst: *aiQuaternion, q: *aiQuaternion) -> void #foreign assimp_vc143_mt;

// --------------------------------------------------------------------------------
/** Performs a spherical interpolation between two quaternions.
* @param dst Receives the quaternion resulting from the interpolation.
* @param start Quaternion when factor == 0
* @param end Quaternion when factor == 1
* @param factor Interpolation factor between 0 and 1
*/
aiQuaternionInterpolate :: (dst: *aiQuaternion, start: *aiQuaternion, end: *aiQuaternion, factor: float) -> void #foreign assimp_vc143_mt;

// Forward declare aiNode (pointer use only)
aiNode :: struct {
    /** The name of the node.
    *
    * The name might be empty (length of zero) but all nodes which
    * need to be referenced by either bones or animations are named.
    * Multiple nodes may have the same name, except for nodes which are referenced
    * by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
    *
    * Cameras and lights reference a specific node by name - if there
    * are multiple nodes with this name, they are assigned to each of them.
    * <br>
    * There are no limitations with regard to the characters contained in
    * the name string as it is usually taken directly from the source file.
    *
    * Implementations should be able to handle tokens such as whitespace, tabs,
    * line feeds, quotation marks, ampersands etc.
    *
    * Sometimes assimp introduces new nodes not present in the source file
    * into the hierarchy (usually out of necessity because sometimes the
    * source hierarchy format is simply not compatible). Their names are
    * surrounded by @verbatim <> @endverbatim e.g.
    *  @verbatim<DummyRootNode> @endverbatim.
    */
    mName:           aiString;

    /** The transformation relative to the node's parent. */
    mTransformation: aiMatrix4x4;

    /** Parent node. nullptr if this node is the root node. */
    mParent:         *aiNode;

    /** The number of child nodes of this node. */
    mNumChildren:    u32;

    /** The child nodes of this node. nullptr if mNumChildren is 0. */
    mChildren:       **aiNode;

    /** The number of meshes of this node. */
    mNumMeshes:      u32;

    /** The meshes of this node. Each entry is an index into the
    * mesh list of the #aiScene.
    */
    mMeshes:         *u32;

    /** Metadata associated with this node or nullptr if there is no metadata.
    *  Whether any metadata is generated depends on the source file format. See the
    * @link importer_notes @endlink page for more information on every source file
    * format. Importers that don't document any metadata don't write any.
    */
    mMetaData:       *aiMetadata;
}

// -------------------------------------------------------------------------------
/** The root structure of the imported data.
*
*  Everything that was imported from the given file can be accessed from here.
*  Objects of this class are generally maintained and owned by Assimp, not
*  by the caller. You shouldn't want to instance it, nor should you ever try to
*  delete a given scene on your own.
*/
// -------------------------------------------------------------------------------
aiScene :: struct {
    /** Any combination of the AI_SCENE_FLAGS_XXX flags. By default
    * this value is 0, no flags are set. Most applications will
    * want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
    * bit set.
    */
    mFlags:         u32;

    /** The root node of the hierarchy.
    *
    * There will always be at least the root node if the import
    * was successful (and no special flags have been set).
    * Presence of further nodes depends on the format and content
    * of the imported file.
    */
    mRootNode:      *aiNode;

    /** The number of meshes in the scene. */
    mNumMeshes:     u32;

    /** The array of meshes.
    *
    * Use the indices given in the aiNode structure to access
    * this array. The array is mNumMeshes in size. If the
    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
    * be at least ONE material.
    */
    mMeshes:        **aiMesh;

    /** The number of materials in the scene. */
    mNumMaterials:  u32;

    /** The array of materials.
    *
    * Use the index given in each aiMesh structure to access this
    * array. The array is mNumMaterials in size. If the
    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
    * be at least ONE material.
    */
    mMaterials:     **aiMaterial;

    /** The number of animations in the scene. */
    mNumAnimations: u32;

    /** The array of animations.
    *
    * All animations imported from the given file are listed here.
    * The array is mNumAnimations in size.
    */
    mAnimations:    **aiAnimation;

    /** The number of textures embedded into the file */
    mNumTextures:   u32;

    /** The array of embedded textures.
    *
    * Not many file formats embed their textures into the file.
    * An example is Quake's MDL format (which is also used by
    * some GameStudio versions)
    */
    mTextures:      **aiTexture;

    /** The number of light sources in the scene. Light sources
    * are fully optional, in most cases this attribute will be 0
    */
    mNumLights:     u32;

    /** The array of light sources.
    *
    * All light sources imported from the given file are
    * listed here. The array is mNumLights in size.
    */
    mLights:        **aiLight;

    /** The number of cameras in the scene. Cameras
    * are fully optional, in most cases this attribute will be 0
    */
    mNumCameras:    u32;

    /** The array of cameras.
    *
    * All cameras imported from the given file are listed here.
    * The array is mNumCameras in size. The first camera in the
    * array (if existing) is the default camera view into
    * the scene.
    */
    mCameras:       **aiCamera;

    /**
    *  @brief  The global metadata assigned to the scene itself.
    *
    *  This data contains global metadata which belongs to the scene like
    *  unit-conversions, versions, vendors or other model-specific data. This
    *  can be used to store format-specific metadata as well.
    */
    mMetaData:      *aiMetadata;

    /** The name of the scene itself.
    */
    mName:          aiString;

    /**
    *
    */
    mNumSkeletons:  u32;

    /**
    *
    */
    mSkeletons:     **aiSkeleton;

    mPrivate:       *u8;
}

// -----------------------------------------------------------------------------------
/** @enum  aiPostProcessSteps
*  @brief Defines the flags for all possible post processing steps.
*
*  @note Some steps are influenced by properties set on the Assimp::Importer itself
*
*  @see Assimp::Importer::ReadFile()
*  @see Assimp::Importer::SetPropertyInteger()
*  @see aiImportFile
*  @see aiImportFileEx
*/
// -----------------------------------------------------------------------------------
aiPostProcessSteps :: enum s32 {
    CalcTangentSpace         :: 1;

    JoinIdenticalVertices    :: 2;

    MakeLeftHanded           :: 4;

    Triangulate              :: 8;

    RemoveComponent          :: 16;

    GenNormals               :: 32;

    GenSmoothNormals         :: 64;

    SplitLargeMeshes         :: 128;

    PreTransformVertices     :: 256;

    LimitBoneWeights         :: 512;

    ValidateDataStructure    :: 1024;

    ImproveCacheLocality     :: 2048;

    RemoveRedundantMaterials :: 4096;

    FixInfacingNormals       :: 8192;

    PopulateArmatureData     :: 16384;

    SortByPType              :: 32768;

    FindDegenerates          :: 65536;

    FindInvalidData          :: 131072;

    GenUVCoords              :: 262144;

    TransformUVCoords        :: 524288;

    FindInstances            :: 1048576;

    OptimizeMeshes           :: 2097152;

    OptimizeGraph            :: 4194304;

    FlipUVs                  :: 8388608;

    FlipWindingOrder         :: 16777216;

    SplitByBoneCount         :: 33554432;

    Debone                   :: 67108864;

    GlobalScale              :: 134217728;

    EmbedTextures            :: 268435456;

    ForceGenNormals          :: 536870912;

    DropNormals              :: 1073741824;

    GenBoundingBoxes         :: -2147483648;

    aiProcess_CalcTangentSpace         :: CalcTangentSpace;

    aiProcess_JoinIdenticalVertices    :: JoinIdenticalVertices;

    aiProcess_MakeLeftHanded           :: MakeLeftHanded;

    aiProcess_Triangulate              :: Triangulate;

    aiProcess_RemoveComponent          :: RemoveComponent;

    aiProcess_GenNormals               :: GenNormals;

    aiProcess_GenSmoothNormals         :: GenSmoothNormals;

    aiProcess_SplitLargeMeshes         :: SplitLargeMeshes;

    aiProcess_PreTransformVertices     :: PreTransformVertices;

    aiProcess_LimitBoneWeights         :: LimitBoneWeights;

    aiProcess_ValidateDataStructure    :: ValidateDataStructure;

    aiProcess_ImproveCacheLocality     :: ImproveCacheLocality;

    aiProcess_RemoveRedundantMaterials :: RemoveRedundantMaterials;

    aiProcess_FixInfacingNormals       :: FixInfacingNormals;

    aiProcess_PopulateArmatureData     :: PopulateArmatureData;

    aiProcess_SortByPType              :: SortByPType;

    aiProcess_FindDegenerates          :: FindDegenerates;

    aiProcess_FindInvalidData          :: FindInvalidData;

    aiProcess_GenUVCoords              :: GenUVCoords;

    aiProcess_TransformUVCoords        :: TransformUVCoords;

    aiProcess_FindInstances            :: FindInstances;

    aiProcess_OptimizeMeshes           :: OptimizeMeshes;

    aiProcess_OptimizeGraph            :: OptimizeGraph;

    aiProcess_FlipUVs                  :: FlipUVs;

    aiProcess_FlipWindingOrder         :: FlipWindingOrder;

    aiProcess_SplitByBoneCount         :: SplitByBoneCount;

    aiProcess_Debone                   :: Debone;

    aiProcess_GlobalScale              :: GlobalScale;

    aiProcess_EmbedTextures            :: EmbedTextures;

    aiProcess_ForceGenNormals          :: ForceGenNormals;

    aiProcess_DropNormals              :: DropNormals;

    aiProcess_GenBoundingBoxes         :: GenBoundingBoxes;
}

#scope_file


#if OS == .WINDOWS {
    assimp-vc143-mt :: #library "windows/assimp-vc143-mt";
} else #if OS == .MACOS {
    assimp-vc143-mt :: #library "macos/assimp-vc143-mt";
} else {
    #assert false;
}

